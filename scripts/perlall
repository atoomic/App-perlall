#!/usr/bin/env perl
eval 'exec /usr/bin/env perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use strict;
use App::Rad;
our $VERSION = '0.01';
use Config;
use Cwd ();
use File::Slurp ();
use File::Basename ();

our @opts = (
	  [ "skip=s",   "skip versions (glob-style)" ],
	  [ "newer=s",  "only newer versions (glob-style)" ],
	  [ "older=s",  "only older versions (glob-style)" ],
	  [ "quiet|q",  "Make perlall command quieter" ],
	  [ "verbose|v","Make perlall command say more" ],
	  [ "as=s",     "install perl under given name" ],
	  [ "dryrun!",  "do not execute commands, only print" ],   
	  [ "D=s",      "./configure option" ],
	  [ "A=s",      "./configure option" ],
	  [ "U=s",      "./configure option" ],
	  [ "j=n",      "parallel make" ],
	  [ "notest|n", "skip the test suite on build and makeinstall" ],
	  [ "force|f",  "force install" ],
	  [ "log!",     "skip writing to the log file" ],
	  [ "help|h",   "commands and options" ],
	  [ "debug|d",  "lots of internal debugging output" ],
	  [ "version|V" ]);
App::Rad->import ('debug') if grep /^-d$/, @ARGV;
App::Rad->run();

=head1 NAME

perlall - Create all perls and test a module with all perls

=head1 SYNOPSIS

    perlall build perl5.15.4d-nt
    perlall build perl5.15.4
    perlall build perl5.15.4-d

    perlall init perl5.15.4d-nt DBI $(cat ~/Perl/B-C/t/top100)

    perlall do -MData::Dumper -e'my $a;$b={1=>\$a};$a=\$b;print Dumper($b)'
    perlall --older 5.12 make -Mblib t/0basic.t
    perlall=5.15.4  perlall maketest  	# test with version as ENV
    perlall="5.14*" perlall makeinstall
    perlall cpan My::Module

    perlall maketest "5.*.d*" # test with all debugging, version as option

=head1 DESCRIPTION

B<perlall> is a better L<perlbrew> with perls in the default
F</usr/local/bin/>, and F</usr/local/lib/perl5/VERSION>, instead of
locally.  It is preferred to have write access to the default PREFIX
F</usr/local>.  It does not use L<local::lib>, does not mangle
C<PERL5LIB> and builds and keeps sane global perl installations,
without the need to save and restore internal states.

The currently used perl and all options are stored as alias 
C<p> in F<~/.perlall>

    alias p=perl5.15.4d-nt

Build and init perls:

Version numbers look like C<5.xx.x> and the C<suffix> can be:

  C<d>   DEBUGGING
  C<-nt> non-threaded
  C<-m>  multi

For older perls special patches are applied to successfully build
them.  C<archname> and the archlibs are extended by C<-debug> and
special git suffices. The installed perl binary ditto.

I use perlall on cygwin, mingw (strawberry), linux (debian+centos),
freebsd, openbsd and solaris, with bash, dash and ksh. 
Supporting other platforms besides VMS should not be hard.
freebsd needs sudo from ports.

The do and make* commands always create a log file with the platform 
and version, like F<log.test-centos5-5.10.1d-nt> for C<maketest> or
F<log.install-osx1068-5.15.4> for C<makeinstall>.

=cut

sub setup { 
  $_[0]->register_commands( {-ignore_prefix => '_'} );
  $_[0]->register('install', \&build, "alias to build");
}

sub App::Rad::Help::usage {
    return "Usage: $0 [options] command [arguments]";
}

sub pre_process {
  my $c = shift;
  # XXX Take opts only before the command, not afterwards!
  # $c->getopt( map {$_->[0]} @opts );
  my $cmd = $c->cmd;
  # defaults: for all
  $c->config->{PERLALL_PREFIX} = '/usr/local';
  # build only
  $c->config->{PERLALL_BUILDROOT} = '/usr/src/perl';
  if ($cmd eq 'cpan') {
    $c->config->{cpan} = 'cpan';
    $c->config->{'init-modules'} = 'YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info Params::Util Bundle::CPANReporter2 Math::Round Params::Classify Bundle::CygwinVendor YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse MouseX::Types Task::Kensho';
    if (File::Basename::basename(Cwd::getcwd) =~/^B-C/ and -f "t/top100") {
      $c->config->{'init-modules'} .= " ".join(" ",File::Slurp::read_file("t/top100"));
    }
  }
  # need .perlall config
  if ($cmd =~ /^build|uninstall|init|list|do|make.*|cpan$/) {
    for ( "/etc/perlall", "$ENV{HOME}/.perlall" ) {
      _dot_perlall($c, $_) if -f $_;
    }
    $c->config->{PERLALL_BINDIR} = $c->config->{PERLALL_PREFIX}."/bin"
      unless $c->config->{PERLALL_BINDIR};
    $c->config->{'perl-git'} = $c->config->{PERLALL_BUILDROOT}.'/blead/perl-git'
      unless $c->config->{'perl-git'};
  }
  # expand versions from $ENV{perlall} or just version from first argument
  if ($cmd =~ /^do|make.*|init|cpan|list|uninstall$/) {
    my @p;
    if ( $c->argv->[0] =~ /^(perl)?5\./ ) {
      @p = (shift @{$c->argv});
      if ($p[0] =~ /[\*\?\[]/) {
	@p = @{_expand_env($c, $p[0])};
      }
    } else {
      @p = @{_expand_env($c)};
    }
    $c->stash->{perlall} = \@p;
  }
}

# only process opts before the command. 
# all other opts are passed verbatim to the subprocesses
sub App::Rad::_get_input {
    my $c = shift;
    require Getopt::Long;
    Carp::croak "Getopt::Long needs to be version 2.36 or above"
        unless $Getopt::Long::VERSION >= 2.36;

    my (@options, @params);
    for (my $i=0; $i<@ARGV; $i++) {
      if (defined ($ARGV[$i]) and substr($ARGV[$i], 0, 1) ne '-') {
	$c->{'cmd'} = $ARGV[$i];
	@params = @ARGV[$i..$#ARGV];
	shift @params;
	last;
      }
      push @options, ($ARGV[$i]);
    }
    @{$c->argv} = @params;
    my $parser = new Getopt::Long::Parser;
    $parser->configure( qw(bundling) );
    my @tARGV = @ARGV; # keep em
    @ARGV = @options;
    my $ret = $parser->getoptions($c->{'_options'}, map {$_->[0]} @opts);
    $c->debug('received options: ' . join(' ',@options));
    $c->debug('received command: ' . $c->{'cmd'});
    $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
    @ARGV = @tARGV;
    return $c;	      
}

# decode suffix into wanted archname. needed by build only
# cwd is the builddir after Configure
sub _suffix2arch {
  my $c = shift;
  my $_ = shift;
  my $arch = "";
  /\dd-?/ and $arch .= "-debug";
  /\dd?-nt/ or $arch .= "-multi-thread";
  /\dd?-m/ or $arch .= "-multi";
  # XXX check for needed git or branch suffix
  return $arch;
}

sub _expand_env {
  my ($c, $glob) = @_;
  unless ($glob) {
    $glob = $ENV{perlall} ? $ENV{perlall} : "5.*";
  }
  my $prefix = $c->config->{PERLALL_BINDIR};
  return [ glob "$prefix/perl$glob" ];
}

sub _dot_perlall {
  my ($c, $filename, $write) = (@_);
  $c->debug("loading configuration from $filename");
  open my $CONFIG, '<', $filename
    or Carp::croak "error opening $filename: $!\n";
  my ($s, $NEW);
  $write = undef if $c->options->{dryrun};
  if ($write) {
    open $NEW, '>', $filename.".tmp"
      or Carp::croak "error opening $filename.tmp: $!\n";
  }
  while (<$CONFIG>) {
    $s = $_ if $write; # backup
    chomp;
    s/#.*//;
    s/^\s+//;
    s/\s+$//;
    print $NEW $s if $s and !length;
    next unless length;

    if ( m/^alias\s([^\=\:\s]+) # alias key=value
	   (?:=['"]?)   # ='
	   ([^'"]+)     # value
	  /x
       ) {
      my ($k,$v) = ($1, $2); 
      if ($k eq 'perl-git') {
	$v =~ s/^cd //;
      }
      $c->config->{$k} = $v;
      if ($write and $k eq 'p') {
	$v = $write;
      }
      print $NEW "alias $k='$v'\n" if $write;
    }
    elsif ( m/^([^\=\:\s]+)          # key
	      (?:                    # (value is optional)
		(?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
		(.+)                 # value
	      )?
	     /x
	  ) {
      $c->config->{$1} = $2;
      print $NEW $s if $write;
    } elsif ($write) {
      print $NEW $s;
    }
  }
  close $CONFIG;
  if ($write) {
    close $NEW;
    unlink $NEW;
    rename $CONFIG, $NEW
      or Carp::croak "error writing $filename: $!\n";
  }
  scalar keys %{$c->config};  
}

sub _system {
  my $c = shift;
  print join(" ",@_),"\n" if $c->options->{verbose};
  system(@_) unless $c->options->{dryrun};
}

sub _fail {
  my $c = shift;
  warn $c->{output} if $c->options->{verbose};
  die "@_\n";
}

=head2 COMMANDS

=over

=item B<build> [ perl<version><suffix> [ from ]] 

Build and install the given version of perl.

Unreleased git versions, like blead or smoke-me branches 
get a C<@xxxxxx> suffix. The version can be "blead" which
resolves to the current development version.

The optional 2nd argument C<from> can be a git tag/commit/branch, 
e.g. a smoke-me branch, or a file or url with the perl-*.tar.gz
The branchname is added to the perl suffix, such as perl5.15.4dnt-smokeme-utf8 
or can be overridden with --as.

The specified perl is taken from a perl git repo (specified in ~/.perlall), 
or downloaded via CPAN.

C<man> files are not installed.

C<-Dusedevel> is always used to install versioned executables.

Special site-specific non-default config vars are taken 
from F</usr/local/bin/perl> if different from F</usr/bin/perl>,
such as cf_email, perladmin, ccflags, cc, ldflags, ld, man1dir, 
man3dir, pager, libpth.

=cut

sub build
  :Help(build perl<version><suffix> [ from ])
{
  my $c = shift;
  my @args = @{$c->argv};
  my $p = $args[0];
  if ($p =~ /^(perl)?5\./ ) {
    shift @args;
  } else {
    $c->output("perlall build missing perlversion argument\n");
    $c->execute('help') and return undef;
  }
  $p =~ s/^perl//;
  $p =~ s/^-//;
  if ($p =~ /[\*\?\[]/ or $p !~ /^5\./) {
    $c->output("perlall build invalid perlversion argument $p\n");
    $c->execute('help') and return undef;
  }
  my @options = keys %{$c->options};
  warn "perlall ".(@options?"[-".join(" -",@options)."] ":"")."build $p @args\n";
  # build is allowed to take options after the cmd: as
  $c->getopt( map {$_->[0]} @opts )
    or $c->execute('usage') and return undef;
  my $srcdir;
  my $cwd = Cwd::getcwd();
  END { chdir $cwd if $cwd; }

  my $root = $c->config->{PERLALL_BUILDROOT};
  unless ($root) {
    _fail($c, "Empty PERLALL_BUILDROOT in .perlall");
  }
  unless (-d $root) {
    mkdir($root,0755) or _fail($c, "Cannot create PERLALL_BUILDROOT $root");
  }

  my $from = shift @args ; # might be empty
  my $gitsuffix;
  my $ps = $p;
  $ps =~ s/\-.+$//;
  $ps =~ s/@.+$//;
  $ps =~ s/d$//;
  if ($from) { # looks like a file/url or more like a git branch/tag/commit
    if (-f $from or $from =~ /^https?:|ftp:|rsync:/) { # grab a file
      warn "XXX build from file very very unstable.\n"
	.  "No idea how to know the resulting srcdir yet";
      print "chdir $root\n" if $c->options->{verbose};
      chdir $root;
      if (-f $from) {
	_system($c, "tar xfz $from");
	$srcdir = $root."/perl-$ps";
      } else {
	_system($c, "wget -O perl-$ps.tgz $from");
	_system($c, "tar xfz perl-$ps.tgz");
	$srcdir = $root."/perl-$ps";
      }
    } else { # git it, much better
      $srcdir = $c->config->{'perl-git'};
      $c->debug("cd $srcdir && git checkout $from");
      print "chdir $srcdir\n" if $c->options->{verbose};
      chdir $srcdir or _fail($c, "invalid perl-git cfg $srcdir");
      undef $!;
      _system($c,"git","checkout",$from); # git returns strange values, ignore
      _fail($c, "git checkout $from: $!") if $!;
      $gitsuffix = $from unless $from =~ /^(perl-|v)5\./;
      if ($gitsuffix) {
	if ($gitsuffix =~ /^[a-f0-9]{5,24}$/) {
	  $gitsuffix = "@".substr($gitsuffix,0,6);
	} else {
	  $gitsuffix =~ s/^smoke-me\///;
	  $gitsuffix =~ s/\W//; # collapse non-word chars
	  $gitsuffix = "@".substr($gitsuffix,0,12);
	  # $gitsuffix = "git" if $gitsuffix eq 'blead'; 
	}
      }
    }
  }
  my $make = $Config{make};
  my $sed = $Config{sed};
  $sed = "sed" unless $sed;
  my $cp = $Config{cp};
  $cp = "cp" unless $cp;
  my $rm = $Config{rm};
  $rm = "rm" unless $rm;

  print "chdir $root\n" if $c->options->{verbose};
  chdir $root;
  my $builddir = "build".$p;
  if (-d $builddir) {
    print "chdir $builddir\n" if $c->options->{verbose};
    chdir $builddir;
    _system($c, $rm, "config.h") if -f "config.h";
    _system($c, $rm, "config.sh") if -f "config.sh";
    _system($c, $rm, "Policy.sh") if -f "Policy.sh";
    _system($c, $make, "clean") if -f "Makefile";
  } else {
    print "mkdir $builddir\n" if $c->options->{verbose};
    mkdir($builddir,0755)
      or _fail($c, "Cannot create $builddir. Check your PERLALL_BUILDROOT in ~/.perlall");
    print "chdir $builddir\n" if $c->options->{verbose};
    chdir $builddir;
  }
  # prepare configure options, dependent on options and $p
  my @conf = ("$srcdir/Configure","-de","-Dusedevel","-Dmksymlinks");
  my $debug = $p =~ /\dd-?/;
  my $ithreads = $p !~ /-nt/;
  push @conf, "-DEBUGGING" if $debug;
  push @conf, "-Dusemultiplicity" if $p =~ /\dd?-m/;
  push @conf, (($ithreads ? " -D" :" -U") . "useithreads");
  push @conf, "-D'".$c->options->{D}."'" if $c->options->{D};
  push @conf, "-A'".$c->options->{A}."'" if $c->options->{A};
  push @conf, "-U'".$c->options->{U}."'" if $c->options->{U};
  if (-e "/usr/local/bin/perl") {
    # XXX compare options
    my $x = "/usr/local/bin/perl";
    for (qw(cc ld ccflags ldflags libpth incpth)) {
      my $o = `$x -V:$_`;
      my $n = `grep "^$_=" config.sh`;
    }
  }
  $c->debug(join(" ",@conf)." - missing cc,ld,ccflags,ldflags,libpath stuff");
  _system($c, @conf);

  # fix libs on debug and git-stuff
  if ($gitsuffix or $debug) {
    $c->debug("post-configure archname fixes");
    my $arch = `grep ^archname= config.sh|cut -c10-`;
    chomp $arch;
    $arch =~ s/'//g;
    my $new = $arch;
    $new .= "-debug" if $debug;
    $new .= $gitsuffix if $gitsuffix;
    _system($c, "$sed -i 's,$arch,$new,' config.h config.sh Policy.sh");
    _system($c, "$sed -i 's,bin/perl$ps,bin/perl$p,' config.h config.sh");
    # TODO mandirs
  }

  _system($c, $make); 
  _system($c, "$make test") unless $c->options->{notest}; 
  _system($c, "$make install DESTDIR=$root/inst-$p");

  # XXX on freebsd and windows there's no sudo. well in freebsd ports there is
  my $sudo = $^O =~ /freebsd|cygwin|msys|MSWin32/ ? "" : "sudo";
  # XXX do we need sudo? check writable
  my @c = ($cp, "$root/inst-$p/usr/local/bin/perl5.*","/usr/local/bin/perl$p");
  $sudo = "" if $sudo and -w "/usr/local/bin/perl$p";
  unshift @c, $sudo if $sudo;
  _system($c, @c);

  @c = ($cp, "-r", "$root/inst-$p/usr/local/lib", "/usr/local/");
  $sudo = $^O =~ /freebsd|cygwin|msys|MSWin32/ ? "" : "sudo";
  $sudo = "" if $sudo and -w "/usr/local/lib/perl5/$ps";
  unshift @c, $sudo if $sudo;
  _system($c, @c);

  print $c->output() if $c->options->{verbose};
  my $f = "$ENV{HOME}/.perlall";
  _dot_perlall($c, $f, "perl$p") if -f $f; # set alias
  return "/usr/local/bin/perl$p installed";
}

=item install  [ perl<version><suffix> [ from ]]

alias to build

=cut

#sub install
#  :Help(alias to build)
#{
#  build(@_);
#}

=item B<uninstall> perl<version><suffix>

Uninstalls the given version.

=cut

sub uninstall
  :Help(sudo rm /usr/local/bin/perl <arg> and its libs)
{
  "unimplemented";
}

=item B<init> [perl-<version><suffix> [<modules>...]]

=item perlall="5.*" B<init> [<modules>...]

Installs and updates basic CPAN modules.

Default: $init-modules from ~/.perlall
   (YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info 
   Params::Util Bundle::CPANReporter2 
   B::Flags Opcodes  Math::Round Params::Classify $(cat ~/Perl/B-C/t/top100)
   Bundle::CygwinVendor YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse 
   MouseX::Types Task::Kensho)

=cut

sub init
  :Help(Installs and updates basic CPAN modules)
{
  my $c = shift;
  my @argv = @{$c->argv};
  my $mods = @argv ? join(" ",@argv) : $c->config->{'init-modules'};
  for my $p (@{$c->stash->{perlall}}) {
    # XXX if App::cpan exists -S cpan, otherwise need -MCPAN -e'install qw(mods)'
    warn "$p -S cpan $mods\n";
    system("$p -S cpan $mods");
  }
}

=item B<list> [version*]

List all installed perlall versions

=cut

sub list
  :Help(List all installed perlall versions) 
{
  my $c = shift;
  return join "\n", @{$c->stash->{perlall}};
}

=item B<do> command

Execute commands with all perls from $ENV{perlall}.

For example, run a Hello program:

    perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5*; do
    echo $perl $*
    $perl $*
  done

Restricts perls via ENV:

  perlall="5.14.*d*" perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5.14.*d*; do
    echo $perl $*
    $perl $*
  done

The output depends on your perl installations, and looks like this:

    perl5.12.2-nt -E'say "Hello from $]"'
    Hello from perl-5.012002
    
    perl5.12.3-m -E'say "Hello from $]"'
    Hello from perl-5.012003
    
    perl5.14.2 -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d-nt -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.8.9-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

    perl5.6.2-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

Notice that the commands are not executed in parallel.

=cut

sub do
  :Help(Execute commands with all perls) 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    warn "$p $argv\n";
    system("$p $argv");
  }
}

=item B<make> args

like C<perlall do>, but prepends C<make clean; $perl Makefile.PL; make> 
before executing the arguments.

=cut

sub make
  :Help('perl Makefile.PL; make') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  my $make = $Config{make};
  for my $p (@{$c->stash->{perlall}}) {
    # XXX check MB
    system("$make -s clean");
    warn "$p Makefile.PL\n";
    system("$p Makefile.PL");
    warn "$make\n";
    system("$make");
    if ($argv) {
      warn "$p $argv\n";
      system("$p $argv");
    }
  }
}

=item B<maketest>

like C<perlall make>, but runs C<make test TEST_VERBOSE=1> after C<make>.

=cut

sub maketest
  :Help('make; make test') 
{
  my $c = shift;
  my $make = $Config{make};
  for my $p (@{$c->stash->{perlall}}) {
    # XXX check MB
    system("$make -s clean");
    warn "$p Makefile.PL\n";
    system("$p Makefile.PL");
    warn "$make\n";
    system("$make");
    if ($c->options->{quiet}) {
      warn "$make test\n";
      system("$make test");
    } else {
      warn "$make test TEST_VERBOSE=1\n";
      system("$make test TEST_VERBOSE=1");
    }
  }
}

=item B<makeinstall>

like C<perlall maketest>, but runs C<sudo make install> after C<make test>.

=cut

sub makeinstall
  :Help('make test && sudo make install') 
{
  my $c = shift;
  my $make = $Config{make};
  for my $p (@{$c->stash->{perlall}}) {
    # XXX check MB
    system("$make -s clean");
    warn "$p Makefile.PL\n";
    system("$p Makefile.PL");
    warn "$make\n";
    system("$make");
    # XXX check MyCPAN.pm for sudo
    warn "$make test && sudo $make install\n";
    system("$make test && sudo $make install");
  }
}

=item B<selfupgrade>

This command upgrades perlall to its latest version.

=cut

sub selfupgrade
  :Help(upgrade perlall to its latest version) 
{
  my $c = shift;
  "unimplemented" # see perlbrew
}

=item B<help>

prints this help. With -v even more.

=cut

sub help
  :Help('list of commands. With -v more')
{
  my $c = shift;
  $c->getopt( 'verbose|v' );
  require Pod::Usage;
  return Pod::Usage::pod2usage
    ( { -message => App::Rad::Help::usage() . "\n\n"
	. App::Rad::Help::helpstr($c),
	-verbose => $c->options->{verbose} ? 3 : 0,
      } );
}

=item B<version>

=cut

sub version
  :Help(print version)
{
  warn "perlapp $main::VERSION\n";
  exit;
}

=back

=head2 OPTIONS

=item B<-f| --force>

Force installation of a perl.

=item B<-j>C<number>

Enable parallel make and test (if supported by the target perl)

  perlall build -j5 perl5.12.3

=item B<-n| --notest>

Skip the test suite

=item B<--skip> C<versions>

versions might be a glob-style regex.
E.g. --skip '5.1[024]d*'

=item B<--newer> C<versions>

Only with newer versions than. versions might be a glob, 
including a special arch suffix.
E.g. perlall do --newer "5.10.?d-nt" 

=item B<--older> C<versions>

versions might be a regex. As in --newer.

=item B<-q| --quiet>

Make perlall command quieter.

=item B<-v| --verbose>

Make perlall command say more.

For C<build> command, this prints the building whole process to STDOUT.

=item B<--as>

Install a given perl under the given name.

    perlall build perl5.6.2 -Dusemymalloc --as perl5.6.2-mymalloc
    perlall build perlblead-nt smoke-me/test --as perl5.15.4-test

=item B<-D>, B<-U>, B<-A>

pass through switches to the perl Configure script.

    perlall build perl5.10.1-nt -Dusemymalloc -Uuselargefiles

=back

=head1 CONFIGURATION

=over 4

=item ~/.perlall

This is shell-script syntax with ENV vars and aliases. 
C<alias p=$perlall> is also written by perlall.
 
    alias perl-git="cd /usr/src/perl/blead/perl-git"
    alias p=perl5.15.4d-nt

C<perl-git> stores the perl src root, which is also a handy alias to cd into it.

Valid vars: 

    PERLALL_PREFIX  - Where perls are installed into. Default: /usr/local
    PERLALL_BINDIR  - Where perl5 binaries. Default: PREFIX/bin
    PERLALL_BUILDROOT - Where perls are built. Default: /usr/src/perl
    alias perl-git  - blead root with .git to avoid downloading perl-*.tar.gz from CPAN
    alias p         - save current perl
    cpan 	    - cpan or cpanm
    init-modules    - list of CPAN module names

=back

=head1 SEE ALSO

The bash scripts, which I used for some years:
L<http://github.com/rurban/dot-bin/blob/master/perlall-makeinstall>

L<App::perlbrew> which looked like my bash scripts and B<perlall>
but pollutes PERL5LIB and thus your whole environment, similar to
the horrible Oracle perl.

=cut
