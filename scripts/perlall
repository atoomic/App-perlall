#!/usr/bin/env perl
eval 'exec /usr/bin/env perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

# TODO:
#   special build patches: dbm, ... See bisect-runner.pl
#   testvm (from perltestvm bash script, with load balancing)
#   trap Ctrl-Break in subprocesses
#   more args (as,force,j,...)
#   build perlbrew and HOME friendly (not hardcoded paths)
#   windows support (paths, tee, tools), die on VMS, beos, ...
#   tests: check opts-mix with hardlinks cmd, opts vs params (if config->linked)

use strict;
use App::Rad;
our $VERSION = '0.01';
use Config;
use Cwd ();
use File::Basename 'basename';
use IO::Tee;

our @opts = (
	  [ "skip=s",   "skip versions (glob-style)" ],
	  [ "newer=s",  "only newer and same versions (glob-style)" ],
	  [ "older=s",  "only older versions (glob-style)" ],
	  [ "nogit",    "skip @ git versions" ],
	  [ "quiet|q",  "no TEST_VERBOSE, no exec STDOUT" ],
	  [ "verbose|v","Make perlall command say more" ],
	  [ "as=s",     "install perl under given name" ],
	  [ "dryrun!",  "do not execute commands, only print" ],   
	  [ "D=s",      "./configure option" ],
	  [ "A=s",      "./configure option" ],
	  [ "U=s",      "./configure option" ],
	  [ "j=n",      "parallel make (>5.10)" ],
	  [ "link",     "make symlinks with git" ],
	  [ "notest|n", "skip the test suite on build and makeinstall" ],
	  [ "force|f",  "force install" ],
	  [ "nolog",    "skip writing log files" ],
	  [ "help|h",   "commands and options" ],
	  [ "debug|d",  "lots of internal debugging output" ],
	  [ "version|V" ]);
App::Rad->import ('debug') if grep /^-d$/, @ARGV;
App::Rad->run();

=head1 NAME

perlall - Create perls and test with all perls

=head1 SYNOPSIS

    perlall build perl5.15.4d-nt
    perlall build perl5.15.4
    perlall build perl5.14.2-nt
    perlall -v build 5.15.4d-nt@khw-tk smoke-me/khw-tk

    perlall init perl5.15.4d-nt DBI CPAN::SQLite $(cat ~/Perl/B-C/t/top100)

    perlall do -MData::Dumper -e'my $a;$b={1=>\$a};$a=\$b;print Dumper($b)'
    perlall --older 5.12 make -Mblib t/0basic.t
    perlall=5.15.4  perlall maketest  	# test with version as ENV
    perlall="5.14*" perlall makeinstall
    perlall cpan My::Module
    perlall cpanm More::Modules

    perlall maketest "5.*.d*" # test with all debugging, version as option

=head2 Planned Features

    perlall smoke blead smoke-me/*
    perlall cpan Devel::*
    perlall testvm centos4 centos5 centos6 solaris10 freebsd7 freebsd8 openbsd89 cygwin
    perlall testvm --all
    perlall selfupgrade
    perlall uninstall perl5.15.4d-nt@khw-tk

=head1 OPTIONS

	  "skip=s",   "skip versions (glob-style)"
	  "newer=s",  "only newer and same versions (glob-style)"
	  "older=s",  "only older versions (glob-style)"
	  "nogit",    "skip @ git versions"
	  "quiet|q",  "Make perlall command quieter"
	  "verbose|v","Make perlall command say more"
	  "dryrun!",  "do not execute commands, only print"
	  "D=s",      "./configure option"
	  "A=s",      "./configure option"
	  "U=s",      "./configure option"
	  "j=n",      "parallel make" (NOT YET)
	  "link",     "-Dmksymlinks with git, otherwise copy"
	  "notest|n", "skip the test suite on build and makeinstall"
	  "force|f",  "force install"
	  "log!",     "skip writing to the log file"
	  "help|h",   "commands and options"
	  "debug|d",  "lots of internal debugging output"
	  "version|V"

=head1 DESCRIPTION

B<perlall> is a better L<perlbrew> with perls in the default
F</usr/local/bin/>, and F</usr/local/lib/perl5/VERSION>, instead of
locally. You need write access to the default PREFIX
F</usr/local>, e.g. via C<sudo>. 
It does not use L<local::lib>, does not mangle C<PERL5LIB> and builds 
and keeps sane global perl installations with special suffices,
without the need to save and restore internal states.
The suffices are used in postprocessing scripts to keep arch-features together.

The currently used perl together with more options is stored as alias 
C<p> in F<~/.perlall>.

    alias p=perl5.15.4d-nt

Build and init perls:

Version numbers look like C<5.xx.x> and the C<suffix> can be any of:

  C<d>    DEBUGGING
  C<-nt>  non-threaded, or
  C<-m>   multi
  C<@xxx> git ids

You want to switch to using a "thr" suffix, then the default
is non-threaded. This behaviour is controlled via the config setting 
C<usethrsuffix=1>.

For older perls special patches are applied to successfully build
them.  C<archname> and the archlibs are extended by C<-debug> and
special git suffices. The installed perl binary ditto.

I use perlall on cygwin, linux (debian+centos),
freebsd, openbsd and solaris, with bash, dash and ksh. 
Supporting other platforms besides VMS should not be hard.
freebsd needs sudo from ports. mingw (strawberry) support is planned.

The do and make* commands always create a log file with the platform 
and version, like F<log.test-centos5-5.10.1d-nt> for C<maketest> or
F<log.install-osx1068-5.15.4> for C<makeinstall>. (NOT YET)

In L<B::C> there are post-processing scripts 
F<status_upd> and F<store_rpt> for those generated logfiles.

=cut

sub setup { 
  $_[0]->register_commands( {-ignore_prefix => '_'} );
  $_[0]->register('install', \&build, "alias to build");
  $_[0]->register('smoke', \&build, "smoke [ perl<version><suffix> from ]");
  $_[0]->unregister('basename'); #imported (bug)
}

sub App::Rad::Help::usage {
    return "Usage: $0 [options] command [arguments]";
}

sub pre_process {
  my $c = shift;
  my $cmd = $c->cmd;

  # config defaults: for all
  $c->config->{PERLALL_PREFIX} = '/usr/local';
  # build only
  $c->config->{PERLALL_BUILDROOT} = '/usr/src/perl';
  if ($cmd eq 'cpan') {
    $c->config->{cpan} = 'cpan';
    $c->config->{'init-modules'} = 'YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info Params::Util Bundle::CPANReporter2 Math::Round Params::Classify Bundle::CygwinVendor YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse MouseX::Types Task::Kensho';
    if (basename(Cwd::getcwd) =~/^B-C/ and -f "t/top100") {
      require File::Slurp;
      $c->config->{'init-modules'} .= " "
	.join(" ",File::Slurp::read_file("t/top100"));
    }
  }
  my $sudo = $^O =~ /freebsd|cygwin|msys|MSWin32/ ? "" : "sudo";
  $c->config->{sudo} = $sudo;

  # read .perlall config. cpan/cpanm not
  if ($cmd =~ /^build|uninstall|init|list|testvm|smoke|do|make.*$/) {
    for ( "/etc/perlall", "$ENV{HOME}/.perlall" ) {
      _dot_perlall($c, $_) if -f $_;
    }
    $c->config->{PERLALL_PREFIX} = '/usr/local'
      unless $c->config->{PERLALL_PREFIX};
    $c->config->{PERLALL_BINDIR} = $c->config->{PERLALL_PREFIX}."/bin"
      unless $c->config->{PERLALL_BINDIR};
    $c->config->{PERLALL_BUILDROOT} = '/usr/src/perl'
      unless $c->config->{PERLALL_BUILDROOT};
    $c->config->{'perl-git'} = $c->config->{PERLALL_BUILDROOT}.'/blead/perl-git'
      unless $c->config->{'perl-git'};

    # logging + locking
    # "we should not disturb a running perlall in this dir"
    require Devel::Platform::Info;
    my $d = Devel::Platform::Info->new->get_info();
    my $s = $d->{oslabel}.$d->{osvers}; $s=~s/\s//g;
    $c->stash->{logprefix} = "log.$cmd-".lc($s)."-";

    if (-f "perlall.lock") {
      print "perlall.lock exists. Probably perlall still running.\n";
      system("pgrep","-fl","perlall");
      exit 1;
    }
    open LOCK,">","perlall.lock";
    print LOCK $$,"\n";
    close LOCK;
    END {
      my $l = "perlall.lock";
      if (-f $l) {
	open LOCK,"<",$l;
	my $pid = <LOCK>;
	close LOCK;
	if ($$ == $pid) {
	  unlink $l;
	} else {
	  warn "Other perlall process $pid still running\n";
	  unlink $l;
	}
      }
    }
  }

  # accept multiple versions?
  # expand versions from $ENV{perlall} or version from first argument
  if ($cmd =~ /^do|make.*|init|cpanm?|list|uninstall$/) {
    my @p;
    if ( $c->argv->[0] =~ /^(perl)?5\./ ) {
      @p = (shift @{$c->argv});
      if ($p[0] =~ /[\*\?\[]/) { # only glob if necessary
	$p[0] =~ s/^perl//;
	@p = _get_perlall($c, $p[0]);
      } else {
	$p[0] =~ s/^5\./perl5\./;
      }
    } else {
      @p = _get_perlall($c);
    }
    $c->stash->{perlall} = \@p;
  }
}

# add opts for specific commands
# getopts overwites the old opts
sub App::Rad::addopts {
  my $c = shift;
  my $savopts = $c->options;
  $c->getopt( @_ );
  $c->options->{$_} = $savopts->{$_} for keys %$savopts; # merge with old opts
}

# only process opts before the command. 
# all other opts are passed verbatim to the subprocesses
sub App::Rad::_get_input {
    my $c = shift;
    require Getopt::Long;
    Carp::croak "Getopt::Long needs to be version 2.36 or above"
        unless $Getopt::Long::VERSION >= 2.36;

    my (@options, @params);
    my $base = basename($0);
    my $cmd;
    if ($base ne 'perlall') {
      # take cmd from link name
      ($cmd) = $base =~ /perlall-(\w+)$/;
      $c->{'cmd'} = $cmd;
      unless ($c->is_command($cmd)) {
	warn "invalid link $base: unknown Command $cmd\n"; 
	return;
      }
      $c->config->{linked} = $cmd;
    }
    for (my $i=0; $i<@ARGV; $i++) {
      if (defined ($ARGV[$i]) and substr($ARGV[$i], 0, 1) ne '-') {
	$c->{'cmd'} = $ARGV[$i] unless $cmd;
	@params = @ARGV[$i..$#ARGV];
	shift @params;
	last;
      }
      push @options, ($ARGV[$i]);
    }
    @{$c->argv} = @params;
    my $parser = new Getopt::Long::Parser;
    $parser->configure( qw(bundling) );
    @ARGV = @options; # getoptions eats @ARGV
    my $ret = $parser->getoptions($c->{'_options'}, map {$_->[0]} @opts);
    $c->debug('received options: ' . join(' ',@options) . ' => ' 
	      . _opts($c->options));
    $c->debug('received command: ' . $c->{'cmd'});
    $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
    @ARGV = @{$c->argv};
    return $c;	      
}

sub _get_perlall {
  my ($c, $glob) = @_;
  unless ($glob) {
    $glob = $ENV{perlall} ? $ENV{perlall} : "5.*";
  }
  die "invalid version $glob" if $glob !~ /^5\./ or $glob =~ /[!"';,\(\)]/;
  my $prefix = $c->config->{PERLALL_BINDIR};
  $prefix = "/usr/local/bin" unless $prefix;
  my @p = glob "$prefix/perl$glob";
  # do the filtering
  @p = grep !/\@/,@p if $c->options->{nogit};
  # hmm, glob-style
  my %skip;
  if ($c->options->{skip}) {
    %skip = map {$_ => 1} glob "$prefix/perl".$c->options->{skip};
  }
  if ($c->options->{older}) {
    # XXX if last char is non-decimal match this suffix filter also
    my $ver = $c->options->{older};
    for (@p) {
      $skip{$_}++ if _older($c, $_, $ver);
    }
  }
  if ($c->options->{newer}) { #or same
    my $ver = $c->options->{newer};
    # XXX if last char is non-decimal match this suffix filter also
    for (@p) {
      $skip{$_}++ unless _older($c, $_, $ver);
    }
  }
  %skip ? grep(!$skip{$_},@p) : @p;
}

# string of hash key=val...
sub _opts {
  my $h = shift;
  my $s = '';
  for (keys %$h) {
    my $v = $h->{$_};
    $s .= ($v != 1 ? " --".$_."=$v" : " --".$_);
  }
  substr($s,1);
}

# $p gets full path
sub _older {
  my $c = shift;
  my ($p, $ver) = @_;
  $p =~ s/^.*perl5\.//;
  $p =~ s/^5\.//;
  $p =~ s/(\.\d+)\D.*$/\1/;
  # perl5.14.2d-nt@345aef vs 5.12 => 14.2 vs 12
  $ver =~ s/^5\.//;
  $c->debug("_older($_[0],$_[1]) => $p,$ver");
  return $p < $ver;
}

sub _dot_perlall {
  my ($c, $filename, $write) = (@_);
  $c->debug(($write?"writing":"loading")." configuration from $filename");
  open my $CONFIG, '<', $filename
    or Carp::croak "error opening $filename: $!\n";
  my ($s, $NEW);
  $write = undef if $c->options->{dryrun};
  if ($write) {
    open $NEW, '>', $filename.".tmp"
      or Carp::croak "error opening $filename.tmp: $!\n";
  }
  while (<$CONFIG>) {
    $s = $_ if $write; # backup
    chomp;
    s/#.*//;
    s/^\s+//;
    s/\s+$//;
    print $NEW $s if $s and !length;
    next unless length;

    if ( m/^alias\s([^\=\:\s]+) # alias key=value
	   (?:=['"]?)   # ='
	   ([^'"]+)     # value
	  /x
       ) {
      my ($k,$v) = ($1, $2); 
      if ($k eq 'perl-git') {
	$v =~ s/^cd //;
	$c->config->{$k} = $v;
	$v = "cd ".$v;
      } else {
	$c->config->{$k} = $v;
      }
      if ($write and $k eq 'p') {
	$v = $write;
      }
      print $NEW "alias $k='$v'\n" if $write;
    }
    elsif ( m/^([^\=\:\s]+)          # key
	      (?:                    # (value is optional)
		(?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
		(.+)                 # value
	      )?
	     /x
	  ) {
      $c->config->{$1} = $2;
      print $NEW $s if $write;
    } elsif ($write) {
      print $NEW $s;
    }
  }
  close $CONFIG;
  if ($write) {
    close $NEW;
    unlink $CONFIG;
    rename $filename.".tmp", $filename
      or Carp::croak "error writing $filename: $!\n";
  }
  scalar keys %{$c->config};  
}

# store alias p if explicitly wished (2nd arg $p), 
# or if only one version was selected. received with no perl prefix
sub _set_alias {
  my ($c, $p) = @_;
  my $f = "$ENV{HOME}/.perlall";
  unless ($p) {
    $p = $c->stash->{perlall}->[0] if @{$c->stash->{perlall}} == 1;
    _dot_perlall($c, $f, $p) if -f $f and $p; # set alias
  } else {
    _dot_perlall($c, $f, "perl$p") if -f $f and $p; # set alias
  }
  ""
}

sub _numonly {
  my $p = shift;
  $p =~ s/^.*perl//;
  $p =~ s/\-.+$//;
  $p =~ s/@.+$//;
  $p =~ s/thr$//;
  $p =~ s/d$//;
  return $p;
}

sub _short {
  my $p = shift;
  $p =~ s/^.*perl//;
  return $p;
}

sub _system {
  my $c = shift;
  _log($c, @_) unless $c->options->{quiet};
  unless ($c->options->{dryrun}) {
    # native chdir/rmdir/mkdir/unlink
    if ($_[0] =~ /^chdir|rmdir|mkdir|unlink$/) {
      my $cmd = shift @_;
      my $what = join "','",@_;
      eval "$cmd('$what')";
      print $! if $!; return 0 if $!;
    } else {
      $c->options->{verbose} ? system(@_) : qx(@_);
    }
  } else { return 0 };
}

sub _log {
  my $c = shift;
  my $q = $c->options->{quiet};
  my $log = $c->stash->{log};
  my $fh  = $c->stash->{log_fh};
  my $v = $c->options->{verbose};
  my $dryrun = $c->options->{dryrun};
  if ($log) {
    if ( !$fh ) {
      if ( $v and !$dryrun ) {
	# STDERR also doubles all console prints. but we want system messages
	$fh = IO::Tee->new(\*STDOUT, \*STDERR, ">$log");
      } else {
	$fh = $q ? IO::File->new(">>$log") : \*STDOUT;
	select $fh if $q;
      }
      $c->stash->{log_fh} = $fh;
    }
    print $fh join(" ",@_),"\n" unless $q;
  } else {
    print join(" ",@_),"\n" if $v;
  }
}

sub _teardown {
  my $c = shift;
  close $c->stash->{log_fh} if $c->stash->{log_fh};
  ""
}

sub _fail {
  my $c = shift;
  warn $c->{output} if $c->options->{verbose};
  die "@_\n";
}

=head2 COMMANDS

=over

=item B<build> [ perl<version><suffix> [ from ]]

Build and install the given version of perl.

The optional 2nd argument C<from> can be a git tag/commit/branch id,
e.g. a smoke-me branch, or a file or url with the perl-*.tar.gz. 
The branchname or commit-id is added to the archname and dll suffix, such as
C<@sproututf8> for C<sprout/utf8>, the binary name is taken from the
first argument. All unreleased git versions, like C<blead> or C<smoke-me>
branches get a C<@gitid> suffix. C<smoke-me/> is stripped from the
suffix.

If the checkout from a bit branch is not a release, the suffix will be
marked with C<@> and the sources are copied to the
builddir. C<-Dmksymlinks> is not used, unless the option C<--link> is
specified.

On cygwin and windows the perl*.dll also gets the suffix, because they
are stored globally. (NOT YET)

The specified perl is taken from a perl git repo 
(specified via perl-git in ~/.perlall), or downloaded via CPAN. (not yet)

C<man> files are not installed. This is the job for the default 
/usr/local/bin/perl or /usr/bin/perl.

C<-Dusedevel> is always used to install versioned executables.

Special site-specific non-default config vars are taken from
F</usr/local/bin/perl>, such as C<cf_email, perladmin, ccflags, cc,
ldflags, ld, pager, libpth, incpth, useshrplib>.

The builddir is under PERLALL_BUILDROOT (Default: "/usr/src/perl")
as "build-E<lt>versionE<gtE<lt>suffix>"
The intermediate "make install DESTDIR" as "inst-E<lt>versionE<gtE<lt>suffixE<gt>".

Specific options: -D -A -U -j --link --as --notest --force

=cut

sub build
  :Help(build [opts] perl<version><suffix> [ from ])
{
  my $c = shift;
  my @args = @{$c->argv};
  my $p = $args[0];
  if ($p =~ /^(perl)?5\./ ) {
    shift @args;
  } else {
    $c->output("perlall build missing perlversion argument\n");
    $c->execute('help') and return undef;
  }
  $p =~ s/^perl//;
  $p =~ s/^-//;
  if ($p =~ /[\*\?\[]/ or $p !~ /^5\./) {
    $c->output("perlall build invalid perlversion argument $p\n");
    $c->execute('help') and return undef;
  }
  # build is allowed to take all options after the cmd
  if (@args) {
    $c->addopts( map {$_->[0]} @opts );
  }
  $c->stash->{log} = $c->stash->{logprefix} . $p;
  _log($c,"perlall",_opts($c->options),"build",$p,@args);
  _fail("build not yet supported on Windows") if $^O eq 'MSWin32';
  my $srcdir;
  my $cwd = Cwd::getcwd();
  END { chdir $cwd if $cwd; }

  my $root = $c->config->{PERLALL_BUILDROOT};
  my $prefix = $c->config->{PERLALL_PREFIX};
  unless ($root) {
    _fail($c, "Empty PERLALL_BUILDROOT in .perlall");
  }
  unless (-d $root) {
    _system($c, "mkdir",$root) 
      and _fail($c, "Cannot create PERLALL_BUILDROOT $root");
  }
  my $make = $Config{make};
  my $sed = $Config{sed};
  $sed = "sed" unless $sed;
  my $cp = $Config{cp};
  $cp = "cp" unless $cp;
  my $rm = $Config{rm};
  $rm = "rm" unless $rm;
  my $sudo = $c->config->{sudo};

  my $from = shift @args ; # might be empty
  my $gitsuffix;
  my $ps = $p;
  my $dryrun = $c->options->{dryrun};
  $ps =~ s/\-.+$//;
  $ps =~ s/@.+$//;
  $ps =~ s/thr$// if $c->config->{usethrsuffix};
  $ps =~ s/d$//;
  my @j = ("-j".$c->options->{j}) if $c->options->{j} and !_older($c, $ps, "5.10.0");

  unless ($from) {
    # XXX git only at first
    if ($ps =~ /^5\./ and -d $c->config->{'perl-git'}) {
      $from = _older($c, $ps,"5.10.0") ? "perl-$ps" : "v$ps";
    } else {
      _fail ($c, "could not determine from argument for $p. perl-git missing?");
    }
  }
  undef $!;
  _log($c, "chdir $root") unless $c->options->{quiet};
  chdir $root unless $dryrun;
  my $builddir = "build-".$p;
  # XXX maybe it already exists and is not empty
  if ($from) { # looks like a file/url or more like a git branch/tag/commit
    # file
    if (-f $from or $from =~ /^https?:|ftp:|rsync:/) {
      warn "XXX build from file very very unstable.\n"
	.  "No idea how to know the resulting srcdir yet";
      if (!-f $from) {
	# try CPAN instead?
	_system($c, "wget","-O","perl-$ps.tgz",$from) 
	  and _fail("downloading $from failed");
	$from = "perl-$ps.tgz";
      }
      my @tarx = (($^O eq 'solaris' ? 'gtar' : 'tar'),
	  ($from =~ m/bz2$/ ? 'xjf' : 'xzf' ));
      _system($c, @tarx, $from) and _fail("extracting the tarball $from failed");
      $srcdir = $root."/perl-$ps";
      if (! -d $builddir) {
	# OOPS LOOKS LIKE AN ERROR
	_system($c, "mkdir", $builddir)
	  and _fail($c, "Cannot create $builddir."
		    ." Check your PERLALL_BUILDROOT in ~/.perlall");
      }
      _system($c, "chdir", $builddir);
    }
    else { # git, much better
      $srcdir = $c->config->{'perl-git'};
      _fail($c, "perl-git $srcdir missing") if !-d $srcdir and !$dryrun;
      $gitsuffix = $from unless $from =~ /^(perl-|v)5\./;
      my @cmd = ("mkdir", $builddir);
      unshift @cmd, $sudo if $sudo;
      _system($c, @cmd) unless -d $builddir;
      _fail($c, "invalid builddir $builddir") if !-d $builddir and !$dryrun;

      # mksymlink for blead or branches
      if (!$gitsuffix and !$c->options->{link}) { # cp anew
	$c->debug("copy full git tree anew for $from, no gitsuffix");
	@cmd = ($cp, "-r", "$srcdir/.git", "$builddir/");
	unshift @cmd, $sudo if $sudo; # cannot trust !-w "$builddir/.git";
	_system($c, @cmd);
	$srcdir = "."; # clean copy
      } else {
	$c->debug("working symlinked to perl-git tree \@$gitsuffix");
      }
      _system($c, "chdir", $builddir);# and _fail($c, "invalid builddir $builddir");
      undef $!;
      _system($c, "git","checkout",$from); # git returns strange values, ignore
      _fail($c, "git checkout $from: $!") if $!;
      _system($c, "git","reset","--hard") if $srcdir eq "."; #else do a clean -dxf?

      if ($gitsuffix) {
	if ($gitsuffix =~ /^[a-f0-9]{5,24}$/) {
	  $gitsuffix = "@".substr($gitsuffix,0,6);
	} else {
	  $gitsuffix =~ s/^smoke-me\///;
	  $gitsuffix =~ s/\W//; # collapse non-word chars
          # for blead or HEAD replace by id, a moving target
          if ($gitsuffix =~ /^blead|HEAD$/ and !$dryrun) {
	    $gitsuffix = substr(`git rev-parse $gitsuffix`,0,8);
	  }
	  $gitsuffix = "@".substr($gitsuffix,0,12);
	}
      }
    }
  }

  _system($c, $rm, "config.h") if -f "config.h";
  _system($c, $rm, "config.sh") if -f "config.sh";
  _system($c, $rm, "Policy.sh") if -f "Policy.sh";
  _system($c, $make, @j, "clean") if -f "Makefile";

  # prepare configure options, dependent on options and $p
  my @conf = ("sh","$srcdir/Configure","-de","-Dusedevel",
	      "-Dinstallman1dir=none","-Dinstallman3dir=none");
  # we cannot force archname, because we don't know the resulting name yet
  # we fix that post-configure
  # XXX However we should honor -Darchname
  my $debug = $p =~ /\dd-?/;
  my $ithreads = $p !~ /\dd?-nt/;
  if ($c->config->{usethrsuffix}) {
    $ithreads = $p =~ /\dd?thr/; # perl5.14.2dthr
  }
  push @conf, "-Dmksymlinks" if $srcdir ne "." and (!$gitsuffix or $c->options->{link});
  push @conf, "-DEBUGGING" if $debug;
  push @conf, "-Doptimize=-g3" if $debug and $Config{gccversion}; #-g is lame
  push @conf, "-Dusemultiplicity" if $p =~ /\dd?-m/;
  push @conf, ($ithreads ? "-D" :"-U") . "useithreads";
  push @conf, "-D'".$c->options->{D}."'" if $c->options->{D};
  push @conf, "-A'".$c->options->{A}."'" if $c->options->{A};
  push @conf, "-U'".$c->options->{U}."'" if $c->options->{U};
  # XXX TODO: set libperl name on windows
  $c->debug("config_args: ".join(" ",@conf));
  my $tryperl = "/usr/local/bin/perl";
  if (-e $tryperl) { # use tryperl as template and merge options
    my $tryargs = `$tryperl -V:config_args`;
    $c->debug("old args: $tryargs");
    for my $f (qw(cc ld ccflags ldflags libpth incpth pager 
		  cf_email perladmin useshrplib))
    {
      next if $c->options->{D} =~ /^$f[= ]/
	or $c->options->{A} =~ /^$f[= ]/
	or $c->options->{U} =~ /^$f[= ]/;
      my ($v) = $tryargs =~ /-D ?$f=(.+?) -/;
      if ($f =~ /^use/ and !$v) {
	my ($d) = $tryargs =~ /-([DU])$f /;
	$c->debug("-$d$f");
	push @conf, "-$d$f";
      } elsif ($v) {
	$c->debug("-D$f=$v") if $v;
	push @conf, "-D$f='$v'";
      }
    }
    $c->debug("merged config_args: ".join(" ",@conf));
  }
  # with git branches prefer to cp to keep the debugging src, 
  # no mksymlinks. --link only if you have not enough space.
  if ($gitsuffix and !$c->options->{link}) {
    _system($c, "cp", "-r", "$srcdir/*", ".");
    $conf[1] = "Configure";
  }
  _system($c, @conf);

  # fix libs on debug and git-stuff
  if ($gitsuffix or $debug) {
    $c->debug("post-configure archname fixes");
    my $arch = `grep ^archname= config.sh|cut -c10-` unless $dryrun;
    chomp $arch;
    $arch = "fake-arch" if $dryrun;
    $arch =~ s/'//g;
    my $new = $arch;
    $new .= "-debug" if $debug and $arch !~ /-debug/;
    $new .= $gitsuffix if $gitsuffix  and $arch !~ /$gitsuffix$/;
    if ($c->options->{D} =~ /^archname/) {
      # XXX parse and set
      $new = $c->options->{D};
      $new =~ s/^archname=//;
    }
    _system($c, "$sed -i 's,$arch,$new,' config.h config.sh Policy.sh") 
      if $arch ne $new;
    _system($c, "$sed -i 's,bin/perl$ps,bin/perl$p,' config.h config.sh");
  }
  my $makefile = -f "GNUmakefile" ? "GNUmakefile" : "makefile";
  if (!$dryrun and `grep '<command-line> $makefile`) {
    system($^X,'-nl','-e"print unless /<command-line>/"',$makefile,">$makefile.new");
    system($^X,'-nl','-e"print unless /<command-line>/"',"x2p/$makefile",">x2p/$makefile.new");
    system($cp,"$makefile.new",$makefile);
    system($cp,"x2p/$makefile.new","x2p/$makefile");
  }

  _system($c, $make, @j); 
  if ($c->cmd eq 'smoke') {
    return $c->execute('_smoke', $p, $from, @j); # XXX not yet
  }
  my $testerr = _system($c, $make, @j, "test") unless $c->options->{notest};
  _system($c, $make, @j, "install", "DESTDIR=$root/inst-$p")
    if !$testerr or $c->options->{force};

  # XXX on freebsd and windows there's no sudo. well in freebsd ports there is
  # do we need sudo? check writable
  my @c = ($cp, "$root/inst-$p/usr/local/bin/perl$ps","$prefix/bin/perl$p");
  $sudo = "" if $sudo and -w "$prefix/bin/perl$p";
  unshift @c, $sudo if $sudo;
  _system($c, @c);

  @c = ($cp, "-r", "$root/inst-$p/usr/local/lib", "$prefix/");
  $sudo = "" if $sudo and -w "$prefix/lib/perl5/$ps";
  unshift @c, $sudo if $sudo;
  _system($c, @c);

  chdir $cwd;
  _set_alias($c, $p);

  print $c->output() if $c->options->{verbose};
  return "$prefix/bin/perl$p faked" if $dryrun;
  return -f "$prefix/bin/perl$p"
    ? "$prefix/bin/perl$p installed"
    : "$prefix/bin/perl$p failed to install";
}

=item install  [ perl<version><suffix> [ from ]]

Same as build

=item B<uninstall> perl<version><suffix>

Uninstalls the given version.

=cut

sub uninstall
  :Help(sudo rm /usr/local/bin/perl <arg> and its libs)
{
  "unimplemented";
}

=item B<smoke> [ perl<version><suffix> from ]

Same as build, but reports the testresults to the smokers mailing list.
C<from> may be a wildcard for multiple smoke branches, as C<smoke-me/*>.

=cut

sub _smoke
{
  return "unimplemented";
}

=item B<init> [perl-<version><suffix> [<modules>...]]

=item perlall="5.*" B<init> [<modules>...]

Installs and updates basic CPAN modules.

Default: C<init-modules> in F<~/.perlall>
   (YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info 
   Params::Util Bundle::CPANReporter2 
   B::Flags Opcodes  Math::Round Params::Classify $(cat ~/Perl/B-C/t/top100)
   Bundle::CygwinVendor YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse 
   MouseX::Types Task::Kensho)

Default: C<cpan>=C<cpan> or C<cpanm> in F<.perlall>
Todo: cpan=-MCPAN

=cut

sub init
  :Help(Installs and updates basic CPAN modules)
{
  my $c = shift;
  my @argv = @{$c->argv};
  my $mods = @argv ? join(" ",@argv) : $c->config->{'init-modules'};
  my $cpan = $c->config->{'cpan'};
  $cpan = 'cpan' unless $cpan;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    # XXX if App::cpan exists and works ok, -S cpan
    # otherwise need -MCPAN -e'install qw(mods)'
    _system($c, $p, "-S", $cpan, $mods);
  }
  _set_alias($c);
}

=item B<list> [version*]

List all installed perlall versions

=cut

sub list
  :Help(List all installed perlall versions) 
{
  my $c = shift;
  return join "\n", @{$c->stash->{perlall}};
}

=item B<do> command

Execute commands with all perls from $ENV{perlall}.

For example, run a Hello program:

    perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5*; do
    echo $perl $*
    $perl $*
  done

Restricts perls via ENV:

  perlall="5.14.*d*" perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5.14.*d*; do
    echo $perl $*
    $perl $*
  done

The output depends on your perl installations, and looks like this:

    perl5.12.2-nt -E'say "Hello from $]"'
    Hello from perl-5.012002
    
    perl5.12.3-m -E'say "Hello from $]"'
    Hello from perl-5.012003
    
    perl5.14.2 -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d-nt -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.8.9-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

    perl5.6.2-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

Notice that the commands are not executed in parallel.

=cut

sub do
  :Help(Execute commands with all perls) 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    _system($c, $p, @{$c->argv});
  }
  _set_alias($c);
}

=item B<cpan> modules

like C<perlall do>, but calls perl5.* -S cpan args... for all perls

=cut

sub cpan
  :Help(call cpan with args for all perls) 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    _system($c, $p, "-S", "cpan", @{$c->argv});
  }
  _set_alias($c);
}

=item B<cpanm> modules

like C<perlall cpan>, but uses cpanm.

=cut

sub cpanm
  :Help(call cpanm with args for all perls) 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    _system($c, $p, "-S", "cpanm", @{$c->argv});
  }
  _set_alias($c);
}

=item B<make> args

like C<perlall do>, but prepends C<make -s clean; $perl Makefile.PL; make> 
before executing the arguments.

Also is Build.PL aware but prefers Makefile.PL.

=cut

sub _make {
  my $c = shift;
  my $p = shift;
  my $make = $Config{make};
  # XXX check MB
  _system($c, $make, "-s", "clean") if -f "Makefile";
  $c->stash->{log} = $c->stash->{logprefix} . _short($p);
  if (-f "Makefile.PL") {
    _system($c, $p, "Makefile.PL");
    _system($c, $make);
  } elsif (-f "Build.PL") {
    _system($c, $p, "Build.PL");
    _system($c, $p, "Build");
  }
}

sub make
  :Help('perl Makefile.PL; make') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  my $make = $Config{make};
  for my $p (@{$c->stash->{perlall}}) {
    _make($c, $p);
    if ($argv) { # preserves quotes as in -e'my $a;'
      _system($c, $p, @{$c->argv});
    }
  }
  _set_alias($c);
}

=item B<maketest>

like C<perlall make>, but runs C<make test TEST_VERBOSE=1> after C<make>.
This is the most used feature.

On C<--quiet> or C<-q> does not do TEST_VERBOSE=1

=cut

sub maketest
  :Help('make; make test') 
{
  my $c = shift;
  my $make = $Config{make};
  warn "additional arguments @{$c->argv} ignored\n" if @{$c->argv};
  for my $p (@{$c->stash->{perlall}}) {
    _make($c, $p);
    my @opts = ("test", $c->options->{quiet} ? () : "TEST_VERBOSE=1");
    unshift @opts,"-j".$c->options->{j} if $c->options->{j} and !_older($c, $p,"5.10.0");
    if (!-f "Makefile" and -f "Build") {
      _system($c, $p, "Build", @opts);
    } else {
      _system($c, $make, @opts);
    }
  }
  _set_alias($c);
}

=item B<makeinstall>

like C<perlall maketest>, but runs C<sudo make install> after C<make test>.

=cut

sub makeinstall
  :Help('make test && sudo make install') 
{
  my $c = shift;
  my $make = $Config{make};
  # XXX check MyCPAN.pm for sudo
  warn "additional arguments @{$c->argv} ignored\n" if @{$c->argv};
  my $sudo = $c->config->{sudo};
  for my $p (@{$c->stash->{perlall}}) {
    _make($c, $p);
    _system($c, "$make test && $sudo $make install"); # csh?
  }
  _set_alias($c);
}


=item B<testvm> [<options] <machines>

Does C<perlall maketest> in parallel on remote machines.
C<testvm> is only usable within a perl core builddir/srcdir 
or in a module rootdir.
It shells out to ssh account(s), copies the MANIFEST to the machine, runs 
C<perlall maketest> there and copies the logfiles back.

Options:

    --init  - copy pubkey to .ssh/authorized_keys, perlall to ~bin/
    --up    - only upload
    --prefix=Perl - remote basedir
    --cmd=<remotecmd> any valid perlall command, like
              build, init, makeinstall, smoke. Default: maketest
    --args=<> any remote perlall args
    -j4     - how many machines in parallel. Also --max=n

Config settings:

    testvm="[user@]hostnames..."
    testvm_prefix=Perl - relative remote basepath of your modules
          i.e. local basename = B-Generate => remote: vmhost:Perl/B-Generate
    testvm_max=4       - balancing, default for -j
    testvm_ctl=virsh   - type of vm ctl: virsh, xen-shell, vmrun, VBoXManage

VM Balancing:

    If the remote hosts are VM's on this machine, you can control how many
    VM's should run in parallel, and how they are started and stopped.

    If C<testvm_ctl> is not set, no balancing - start+stop - will be done, 
    such as on physical hosts or enough VM power.

=cut

sub testvm
  :Help('test on remote accounts via ssh/rsync (vm or host)') 
{
  my $c = shift;
  # testvm has a different option set and allows options after the command
  $c->addopts( "init|i", "up", "prefix|p=s", "cmd|c=s", "option|o=s", "max|j=n" );

  my @testvm = split //,$c->config->{testvm};
  my $argv = join " ",@{$c->argv};
  my @machines = $argv ? split(//,$argv) : @testvm;
  # XXX Expand glob-style machines 
  # Idea: - check /etc/hosts so testvm can be empty?
  #       But then we have to check the network for possible machines, 
  #       or we want to do all hosts in /etc/hosts?
  #       - check hosts in .ssh/known_hosts
  # XXX check if in core or in a module
  warn "perlall testvm "._opts($c->options)." @machines\n" 
    if $c->options->{verbose};
  $c->stash->{log} = $c->stash->{logprefix};

  "unimplemented"
}


=item B<selfupgrade>

This command upgrades perlall to its latest version.

=cut

sub selfupgrade
  :Help(upgrade perlall to its latest version) 
{
  my $c = shift;
  "unimplemented" # see perlbrew
}

=item B<help>

prints this help. With -v even more.

=cut

sub help
  :Help('list of commands. With -v more')
{
  my $c = shift;
  $c->addopts( 'verbose|v' );
  require Pod::Usage;
  return Pod::Usage::pod2usage
    ( { -message => App::Rad::Help::usage() . "\n\n"
	. App::Rad::Help::helpstr($c),
	-verbose => $c->options->{verbose} ? 3 : 0,
      } );
}

=item B<version>

=cut

sub version
  :Help(print version)
{
  # hardlink variants (perlall-make, ...)
  print basename($0)." $main::VERSION\n";
  exit;
}

=back

=head2 OPTIONS

=over

=item B<-f| --force>

Force installation of a perl.

=item B<-j>C<number>

Enable parallel make and test (if supported by the target perl)

  perlall build -j5 perl5.12.3

=item B<-n| --notest>

Skip the test suite

=item B<--skip> C<versions>

versions might be a glob-style regex.
E.g. --skip '5.1[024]d*'

=item B<--newer> C<versions>

Only with newer versions than. versions might be a glob, 
including a special arch suffix.
E.g. perlall do --newer "5.10.?d-nt" 

=item B<--older> C<versions>

versions might be a regex. As in --newer.

=item B<-q| --quiet>

Make perlall command quieter.

=item B<-v| --verbose>

Make perlall command say more.

For C<build> command, this prints the building whole process to STDOUT.

=item B<--as>

Install a given perl under the given name.

    perlall build perl5.6.2 -Dusemymalloc --as perl5.6.2-mymalloc
    perlall build perlblead-nt smoke-me/test --as perl5.15.4-test

=item B<-D>, B<-U>, B<-A>

pass through switches to the perl Configure script.

    perlall build perl5.10.1-nt -Dusemymalloc -Uuselargefiles

=back

=head1 CONFIGURATION

B<~/.perlall> or F</etc/perlall>

This is shell-script syntax with ENV vars and aliases. 
C<alias p=$perlall> is also written by C<perlall>.

=over 4

=item alias p=perl5.15.4d-nt

Save current perl.

This is stored after each perlall execution.
Dependend on p there are several other handy p aliases,
which are active if you source them from your F<~/.profile>
See F<.perlall>

=item alias perl-git="cd /usr/src/perl/blead/perl-git"

git repo to avoid downloading perl-*.tar.gz from CPAN.

C<perl-git> stores the perl git root, and is also a handy alias to cd into it.

=item PERLALL_PREFIX

Where perls are installed into. Default: /usr/local

=item PERLALL_BINDIR

Where perl5.* binaries are expected. Currently built into
PERLALL_PREFIX/bin only.

Default: PREFIX/bin but can also be ~/perl5/perlbrew/bin

=item PERLALL_BUILDROOT

Where perls are built. 
Default: /usr/src/perl

=item cpan

For init only.

C<cpan> or C<cpanm> (C<-MCPAN> not yet)

=item init-modules

List of CPAN module names for C<init>

=item sudo

Default: "sudo". Or "" on freebsd|cygwin|msys|MSWin32

=item testvm

See L</testvm>.

=back

=head1 SEE ALSO

The bash scripts, which I used for some years:
L<http://github.com/rurban/dot-bin/blob/master/perlall-makeinstall>

L<App::perlbrew> which looked like my bash scripts and B<perlall>,
but pollutes PERL5LIB and thus your whole environment, similar to
the horrible Oracle perl.

=cut
