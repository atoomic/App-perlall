#!/usr/bin/env perl
eval 'exec /usr/bin/env perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

#BEGIN {$DB::single=1} # debug into attribute handling
# TODO:
#   implement smoke, uninstall, selfupgrade
#   check stable .lock file handling (looks better now)
#   testvm load balancing
#   build perlbrew and HOME friendly (not hardcoded paths)
#   windows support (paths, tee, tools), die on VMS, beos, ...
#   tests: check opts-mix with hardlinks cmd, opts vs params (if config->linked)
#   git-branch globbing (smoke bleadd smoke-me/*)
#   metacpan globbing (cpan Devel::*)

use strict;
use App::Rad;
our $VERSION = '0.01';
use Config;
use Cwd ();
use File::Basename 'basename';
use IO::Tee;
use Devel::Platform::Info;
use Devel::PatchPerl;

push @App::Rad::ISA, 'main';
our @opts = (
	  [ "skip=s",   "skip versions (glob-style)" ],
	  [ "newer=s",  "only newer and same versions (glob-style)" ],
	  [ "older=s",  "only older versions (glob-style)" ],
	  [ "nogit",    "skip @ git versions" ],
	  [ "quiet|q",  "no TEST_VERBOSE, no exec STDOUT" ],
	  [ "verbose|v","Make perlall command say more" ],
	  [ "dryrun!",  "do not execute commands, only print" ],   
	  [ "nolog",    "skip writing log files" ],
	  [ "help|h",   "commands and options" ],
	  [ "debug|d",  "lots of internal debugging output" ],
	  [ "version|V" ]);
App::Rad->import ('debug') if grep /^-d$/, @ARGV;
App::Rad->run();

=head1 NAME

perlall - Create perls and test with all perls

=head1 SYNOPSIS

    perlall build perl5.15.4d-nt
    perlall build perl5.15.4
    perlall build perl5.14.2-nt
    perlall -v build -j4 5.15.4d-nt@khw-tk smoke-me/khw-tk

    perlall init perl5.15.4d-nt DBI CPAN::SQLite $(cat ~/Perl/B-C/t/top100)

    perlall do -MData::Dumper -e'my $a;$b={1=>\$a};$a=\$b;print Dumper($b)'
    perlall --older 5.12 make -Mblib t/0basic.t
    perlall=5.15.4  perlall maketest  	# test with version as ENV
    perlall="5.14*" perlall makeinstall
    perlall cpan My::Module
    perlall cpanm More::Modules

    perlall maketest "5.*.d*" # test with all debugging, version as option

    for m in centos4 centos5 solaris10; do
      perlall initvm -v $m
    done
    perlall testvm centos4 centos5 solaris10
    perlall testvm --all -c=init # see testvm in .perlall

=head2 Planned Features

    perlall smoke -j4 blead smoke-me/*
    perlall cpan Devel::*
    perlall selfupgrade
    perlall uninstall perl5.15.4d-nt@khw-tk

=head1 OPTIONS

	  "skip=s",   "skip versions (glob-style)"
	  "newer=s",  "only newer and same versions (glob-style)"
	  "older=s",  "only older versions (glob-style)"
	  "nogit",    "skip @ git versions"
	  "quiet|q",  "Make perlall command quieter"
	  "verbose|v","Make perlall command say more"
	  "dryrun!",  "do not execute commands, only print"
	  "log!",     "skip writing to the log file"
	  "help|h",   "commands and options"
	  "debug|d",  "lots of internal debugging output"
	  "version|V"

build only:
	  "D=s",      "./configure option"
	  "A=s",      "./configure option"
	  "U=s",      "./configure option"
	  "j=n",      "parallel make" (NOT YET)
	  "link",     "-Dmksymlinks with git, otherwise copy"

build and makeinstall
	  "notest|n", "skip the test suite on build and makeinstall"
	  "force|f",  "force install"

testvm: see L</testvm>

=head1 DESCRIPTION

B<perlall> is a better L<perlbrew> with perls in the default
F</usr/local/bin/>, and F</usr/local/lib/perl5/VERSION>, instead of
locally. You need write access to the default PREFIX
F</usr/local>, e.g. via C<sudo>. 
It does not use L<local::lib>, does not mangle C<PERL5LIB> and builds 
and keeps sane global perl installations with special suffices,
without the need to save and restore internal states.
The suffices are used in postprocessing scripts to keep arch-features together.

The currently used perl together with more options is stored as alias 
C<p> in F<~/.perlall>, which can be sourced by your F<.profile>.

    alias p=perl5.15.4d-nt

Build and init perls:

Version numbers look like C<5.xx.x> and the perl C<suffix> can be any of:

  C<d>    DEBUGGING
  C<-nt>  non-threaded, or
  C<-m>   multi
  C<@xxxxxx> git ids / branch names

You want to switch to using a "thr" suffix, then the default
is non-threaded. This behaviour is controlled via the config setting 
C<usethrsuffix=1>.

For older perls special patches are applied to successfully build
them. C<archname> and the archlibs are extended by C<-debug> and
special git suffices. The installed perl binary and on windows
the F<perl.dll> ditto.

I plan to use perlall on cygwin, linux (debian+centos),
freebsd, openbsd and solaris, with bash, dash and ksh.
Supporting other platforms besides VMS should not be hard.
freebsd needs sudo from ports. mingw (strawberry) support is planned.

The do and make* commands always create a log file with the platform 
and version, like F<log.test-centos5-5.10.1d-nt> for C<maketest> or
F<log.install-osx1068-5.15.4> for C<makeinstall>.

In L<B::C> there are post-processing scripts
F<status_upd> and F<store_rpt> for those generated logfiles.

=cut

sub setup { 
  $_[0]->register_commands( {-ignore_prefix => '_'} );
  $_[0]->register('install', \&build, "alias to build");
  $_[0]->register('smoke', \&build, "smoke [ perl<version><suffix> from ]");
  $_[0]->unregister('basename'); #imported (bug)
}

sub App::Rad::Help::usage {
    return "Usage: $0 [options] command [arguments]";
}

sub pre_process {
  my $c = shift;
  my $cmd = $c->cmd;

  # config defaults: for all
  $c->config->{PERLALL_PREFIX} = '/usr/local';
  # build only
  $c->config->{PERLALL_BUILDROOT} = '/usr/src/perl';
  if ($cmd =~ "init") {
    $c->config->{cpan} = 'cpan';
    $c->config->{'init-modules'} = 'YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info'
      .' Params::Util Bundle::CPANReporter2 Math::Round Params::Classify Bundle::CygwinVendor'
      .' YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse MouseX::Types Modern::Perl'
      .' Task::Kensho';
    if (basename(Cwd::getcwd) =~/^B-C/ and -f "t/top100") {
      require File::Slurp;
      $c->config->{'init-modules'} .= " "
	.join(" ",File::Slurp::read_file("t/top100"));
    }
  }
  my $sudo = $^O =~ /freebsd|cygwin|msys|MSWin32/ ? "" : "sudo";
  $c->config->{sudo} = $sudo;

  # read .perlall config. cpan/cpanm not
  if ($cmd =~ /^build|uninstall|init|list|testvm|smoke|do|make.*$/) {
    for ( "/etc/perlall", "$ENV{HOME}/.perlall" ) {
      $c->_dot_perlall($_) if -f $_;
    }
    $c->config->{PERLALL_PREFIX} = '/usr/local'
      unless $c->config->{PERLALL_PREFIX};
    $c->config->{PERLALL_BINDIR} = $c->config->{PERLALL_PREFIX}."/bin"
      unless $c->config->{PERLALL_BINDIR};
    $c->config->{PERLALL_BUILDROOT} = '/usr/src/perl'
      unless $c->config->{PERLALL_BUILDROOT};
    $c->config->{'perl-git'} = $c->config->{PERLALL_BUILDROOT}.'/blead/perl-git'
      unless $c->config->{'perl-git'};

    if ($cmd !~ /^list/) {
      # logging + locking
      # "we should not disturb a running perlall in this dir"
      my $d = Devel::Platform::Info->new->get_info();
      my $s = $d->{oslabel}.$d->{osvers}; $s=~s/\s//g;
      $c->stash->{logprefix} = "log.$cmd-".lc($s)."-";

      if (-f "perlall.lock") {
	print "perlall.lock exists. Probably perlall still running.\n";
	system("pgrep","-fl","perlall");
	exit 1;
      }
      open LOCK,">","perlall.lock";# XXX where? for build in the builddir
      print LOCK $$,"\n";
      close LOCK;

      $SIG{INT} = $SIG{TERM} = sub {my $l="perlall.lock"; unlink $l if -f $l };
    
      END {
	my $l = "perlall.lock";
	if (-f $l) { # do not override other locks
	  open LOCK,"<",$l;
	  my $pid = <LOCK>;
	  chomp $pid;
	  close LOCK;
	  if ($$ == $pid) {
	    unlink $l;
	  } else {
	    warn "Other perlall process $pid still running. perlall.lock kept\n";
	    #warn `pgrep -Ll $pid`,"\n";
	    # unlink $l;
	  }
	}
      }
    }
  }

  # accept multiple versions?
  # expand versions from $ENV{perlall} or version from first argument
  if ($cmd =~ /^do|make.*|init|cpanm?|list|uninstall$/) {
    my @p;
    if ( $c->argv->[0] =~ /^(perl)?5\./ ) {
      @p = (shift @{$c->argv});
      if ($p[0] =~ /[\*\?\[]/) { # only glob if necessary
	$p[0] =~ s/^perl//;
	@p = $c->_get_perlall($p[0]);
      } else {
	$p[0] =~ s/^5\./perl5\./;
      }
    } else {
      @p = $c->_get_perlall();
    }
    $c->stash->{perlall} = \@p;
  }
}

# add opts for specific commands
# getopts overwites the old opts
sub App::Rad::addopts {
  my $c = shift;
  my $savopts = $c->options;
  $c->getopt( @_ );
  $c->options->{$_} = $savopts->{$_} for keys %$savopts; # merge with old opts
}

# only process opts before the command. 
# all other opts are passed verbatim to the subprocesses
sub App::Rad::_get_input {
    my $c = shift;
    require Getopt::Long;
    Carp::croak "Getopt::Long needs to be version 2.36 or above"
        unless $Getopt::Long::VERSION >= 2.36;

    my (@options, @params);
    my $base = basename($0);
    my $cmd;
    if ($base ne 'perlall') {
      # take cmd from link name
      ($cmd) = $base =~ /perlall-(\w+)$/;
      $c->{'cmd'} = $cmd;
      unless ($c->is_command($cmd)) {
	warn "invalid link $base: unknown Command $cmd\n"; 
	return;
      }
      $c->config->{linked} = $cmd;
    }
    for (my $i=0; $i<@ARGV; $i++) {
      if (defined ($ARGV[$i]) and substr($ARGV[$i], 0, 1) ne '-') {
	$c->{'cmd'} = $ARGV[$i] unless $cmd;
	@params = @ARGV[$i..$#ARGV];
	shift @params;
	last;
      }
      push @options, ($ARGV[$i]);
    }
    @{$c->argv} = @params;
    my $parser = new Getopt::Long::Parser;
    $parser->configure( qw(bundling) );
    @ARGV = @options; # getoptions eats @ARGV
    my $ret = $parser->getoptions($c->{'_options'}, map {$_->[0]} @opts);
    $c->debug('received options: ' . join(' ',@options) . ' => '
	      . _opts($c->options));
    $c->debug('received command: ' . $c->{'cmd'});
    $c->debug('received parameters: ' . join (' ', @{$c->argv} ));
    @ARGV = @{$c->argv};
    return $c;
}

sub _get_perlall {
  my ($c, $glob) = @_;
  unless ($glob) {
    $glob = $ENV{perlall} ? $ENV{perlall} : "5.*";
  }
  die "invalid version $glob" if $glob !~ /^5\./ or $glob =~ /[!"';,\(\)]/;
  my $prefix = $c->config->{PERLALL_BINDIR};
  $prefix = "/usr/local/bin" unless $prefix;
  my @p = glob "$prefix/perl$glob";
  # do the filtering
  @p = grep !/\@/,@p if $c->options->{nogit};
  # glob-style
  my %skip;
  if ($c->options->{skip}) {
    %skip = map {$_ => 1} glob "$prefix/perl".$c->options->{skip};
  }
  if ($c->options->{older}) {
    # XXX if last char is non-decimal match this suffix filter also
    my $ver = $c->options->{older};
    for (@p) {
      $skip{$_}++ if $c->_older( $_, $ver);
    }
  }
  if ($c->options->{newer}) { #or same
    my $ver = $c->options->{newer};
    # XXX if last char is non-decimal match this suffix filter also
    for (@p) {
      $skip{$_}++ unless $c->_older( $_, $ver);
    }
  }
  %skip ? grep(!$skip{$_},@p) : @p;
}

# string of hash key=val...
sub _opts {
  my $h = shift;
  my $s = '';
  for (keys %$h) {
    my $v = $h->{$_};
    if (ref($v) eq 'ARRAY') {
      for my $v (@{$h->{$_}}) {
	$s .= ($v != 1 ? " --".$_."=$v" : " --".$_);
      }
    } else {
      $s .= ($v != 1 ? " --".$_."=$v" : " --".$_);
    }
  }
  substr($s,1);
}

# $p gets full path
sub _older {
  my $c = shift;
  my ($p, $ver) = @_;
  $p =~ s/^.*perl5\.//;
  $p =~ s/^5\.//;
  $p =~ s/(\.\d+)\D.*$/$1/;
  # perl5.14.2d-nt@345aef vs 5.12 => 14.2 vs 12
  $ver =~ s/^5\.//;
  $c->debug("_older($_[0],$_[1]) => $p,$ver");
  return $p < $ver;
}

sub _dot_perlall {
  my ($c, $filename, $write) = (@_);
  $c->debug(($write?"writing":"loading")." configuration from $filename");
  open my $CONFIG, '<', $filename
    or Carp::croak "error opening $filename: $!\n";
  my ($s, $NEW);
  $write = undef if $c->options->{dryrun};
  if ($write) {
    open $NEW, '>', $filename.".tmp"
      or Carp::croak "error opening $filename.tmp: $!\n";
  }
  while (<$CONFIG>) {
    $s = $_ if $write; # backup
    chomp;
    s/#.*//;
    s/^\s+//;
    s/\s+$//;
    print $NEW $s if $s and !length;
    next unless length;

    if ( m/^alias\s([^\=\:\s]+) # alias key=value
	   (?:=['"]?)   # ='
	   ([^'"]+)     # value
	  /x
       ) {
      my ($k,$v) = ($1, $2); 
      if ($k eq 'perl-git') {
	$v =~ s/^cd //;
	$c->config->{$k} = $v;
	$v = "cd ".$v;
      } else {
	$c->config->{$k} = $v;
      }
      if ($write and $k eq 'p') {
	$v = $write;
      }
      print $NEW "alias $k='$v'\n" if $write;
    }
    elsif ( m/^([^\=\:\s]+)          # key
	      (?:                    # (value is optional)
		(?:\s*[\=\:]\s*|\s+) # separator ('=', ':' or whitespace)
		(.+)                 # value
	      )?
	     /x
	  ) {
      $c->config->{$1} = $2;
      print $NEW $s if $write;
    } elsif ($write) {
      print $NEW $s;
    }
  }
  close $CONFIG;
  if ($write) {
    close $NEW;
    unlink $CONFIG;
    rename $filename.".tmp", $filename
      or Carp::croak "error writing $filename: $!\n";
  }
  scalar keys %{$c->config};  
}

# store alias p if explicitly wished (2nd arg $p), 
# or if only one version was selected. received with no perl prefix
sub _set_alias {
  my ($c, $p) = @_;
  my $f = "$ENV{HOME}/.perlall";
  unless ($p) {
    $p = $c->stash->{perlall}->[0] if @{$c->stash->{perlall}} == 1;
    $c->_dot_perlall($f, $p) if -f $f and $p; # set alias
  } else {
    $c->_dot_perlall($f, "perl$p") if -f $f and $p; # set alias
  }
  ""
}

sub _numonly {
  my $p = shift;
  $p =~ s/^.*perl//;
  $p =~ s/\-.+$//;
  $p =~ s/@.+$//;
  $p =~ s/thr$//;
  $p =~ s/d$//;
  return $p;
}

sub _short {
  my $p = shift;
  $p =~ s/^.*perl//;
  return $p;
}
# bold green
sub _print0 {
    print "\033[1;32m",join(" ",@_),"\033[0;0m\n";
}
# bold red/black
sub _print1 {
    print "\033[1;39m",join(" ",@_),"\033[0;0m\n";
}
sub __system {
  my $c = shift;
  unless ($c->options->{dryrun}) {
    # native chdir/rmdir/mkdir/unlink
    if ($_[0] =~ /^chdir|rmdir|mkdir|unlink$/) {
      my $cmd = shift @_;
      my $what = join "','",@_;
      eval "$cmd('$what')";
      # print $! if $!; return 0 if $!;
    } else {
      $c->options->{verbose} ? system(@_) : qx(@_);
    }
  }
}
sub _system {
  my $c = shift;
  unless ($c->options->{quiet}) {
    $c->_log( @_);
  }
  $c->__system(@_); 
}
sub _system0 {
  my $c = shift;
  unless ($c->options->{quiet}) {
    $c->_loginit() if $c->stash->{log} and !$c->stash->{log_fh};
    _print0(@_);
  }
  $c->__system(@_); 
}
sub _system1 {
  my $c = shift;
  unless ($c->options->{quiet}) {
    $c->_loginit() if $c->stash->{log} and !$c->stash->{log_fh};
    _print1(@_);
  }
  $c->__system(@_);
}

sub _loginit {
  my $c = shift;
  my $q = $c->options->{quiet};
  my $v = $c->options->{verbose};
  my $dryrun = $c->options->{dryrun};
  my $log = $c->stash->{log};
  my $fh  = $c->stash->{log_fh};
  if ( $v and !$dryrun ) {
    # only with -v we print to STDOUT also, else only to the log
    $fh = IO::Tee->new(\*STDOUT, ">$log");
    # TODO tee STDERR also to log (2>&1 open3, IPC::Cmd?)
  } else {
    $fh = $q ? IO::File->new(">>$log") : \*STDOUT;
    select $fh if $q;
  }
  $c->stash->{log_fh} = $fh;
}

sub _log {
  my $c = shift;
  my $q = $c->options->{quiet};
  my $v = $c->options->{verbose};
  my $dryrun = $c->options->{dryrun};
  my $log = $c->stash->{log};
  my $fh  = $c->stash->{log_fh};
  local $| = 1;
  if ($log) {
    $c->_loginit unless $fh;
    if (!$q) {
      if ($fh) {
	print $fh join(" ",@_),"\n";
	$fh->flush;
      } else {
	print join(" ",@_),"\n"; # fails on my centos5
      }
    }
  } else {
    print join(" ",@_),"\n" if $v;
  }
}

# print unless /<command-line>/
# s,$dll,$newdll,; print
sub _grep {
  my $c = shift;
  my $cmd = shift;
  # -i inplace
  $c->_log("perl -i -ne'$cmd' ",join(" ",@_));
  return if $c->options->{dryrun};
  while (my $f = shift @_) {
    next unless -f $f;
    my $b = $f."~";
    unlink $b if -e $b;
    rename($f, $b);
    open(IN, "<", $b);
    open(OUT, ">", $f);
    select(OUT);
  LINE: while (<IN>) {
      eval $cmd;
    }
    close IN;
    close OUT;
  }
  select(STDOUT);
}

# takes path to file and applies all os patches from HEAD up to blead
sub _patch {
  my ($c, $file) = @_;
  $c->_system("git show HEAD..blead $file | patch -N -p1") 
    and warn("patch HEAD..blead $file had some errors\n");
}

# like Porting/bisect-runner.pl apply_commit
sub _apply_commit {
  my ($c, $commit, @files) = @_;
  $c->_system("git show $commit @files | patch -N -p1") 
    and warn("cannot apply commit $commit".(@files ? " to @files":"")."\n");
}

sub _teardown {
  my $c = shift;
  close $c->stash->{log_fh} if $c->stash->{log_fh};
  ""
}

sub _fail {
  my $c = shift;
  if ($c->options->{verbose}) {
    warn $c->{output}," at perlall line @{[(caller(0))[2]]}\n";
  }
  die "@_\n";
}

=head2 COMMANDS

=over

=item B<build> [OPTIONS] <version><suffix> [ from ]

Build and install the given version of perl.

The optional 2nd argument C<from> can be a git tag/commit/branch id,
e.g. a smoke-me branch, or a file or url with the perl-*.tar.gz. 
The branchname or commit-id is added to the archname and dll suffix, such as
C<@sproututf8> for C<sprout/utf8>, the binary name is taken from the
first argument. All unreleased git versions, like C<blead> or C<smoke-me>
branches get a C<@gitid> suffix. C<smoke-me/> is stripped from the
suffix. The special version "blead" denotes the latest version.
E.g. C<perlall build blead-nt> builds latest non-threaded.

If the checkout from a bit branch is not a release, the suffix will be
marked with C<@> and the sources are copied to the
builddir. C<-Dmksymlinks> is not used, unless the option C<--link> is
specified.

On cygwin and windows the F<perl*.dll> also gets the suffix, because they
are stored globally. (NOT YET)

The specified perl is taken from a perl git repo 
(specified via perl-git in ~/.perlall), or downloaded via CPAN. (not yet)

C<man> files are not installed. This is the job for the default 
/usr/local/bin/perl or /usr/bin/perl.

C<-Dusedevel> is always used to install versioned executables.

Special site-specific non-default config vars are taken from
F</usr/local/bin/perl>, such as C<cf_email, perladmin, ccflags, cc,
ldflags, ld, pager, libpth, incpth, useshrplib>.

The builddir is under C<PERLALL_BUILDROOT> (Default: "/usr/src/perl")
as "build-E<lt>versionE<gt>E<lt>suffix>"
The intermediate "make install DESTDIR" as "inst-E<lt>versionE<gt>E<lt>suffixE<gt>".

Specific OPTIONS:

  -f|--force    Force installation if make test fails.
  -jnum         Enable parallel make and test (if supported by the target perl)

                perlall build -j5 perl5.12.3

  --link        Force -Dmksymlinks to the srcdir. Otherwise releases from git 
                are copied anew.
  -n|--notest   Skip the test suite
  --as name     Install a given perl under the given name.

    perlall build perl5.6.2 -Dusemymalloc --as perl5.6.2-mymalloc
    perlall build perlblead-nt smoke-me/test --as perl5.15.4-test

  -D.. -U.. -A..  pass through switches to the perl Configure script.

    perlall build perl5.10.1-nt -Dusemymalloc -Uuselargefiles

    Certain special switches are merged from F</usr/local/bin/perl> or F</usr/bin/perl>

=cut

sub build
  :Help('build [opts] perl<version><suffix> [ from ]')
{
  my $c = shift;
  # special build options (after the cmd)
  if (@{$c->argv}) {
    my @build_opts =
      (
       [ "as=s",     "install perl under given name" ],
       [ "D=s@",     "./configure option" ],
       [ "A=s@",     "./configure option" ],
       [ "U=s@",     "./configure option" ],
       [ "j=n",      "parallel make (>5.10)" ],
       [ "link",     "make symlinks with git" ],
       [ "notest|n", "skip the test suite on build and makeinstall" ],
       [ "force|f",  "force install" ]
      );
    $c->addopts( map {$_->[0]} @build_opts );
  }
  my @args = @{$c->argv};
  my $p = $args[0];
  if ($p =~ /^(perl)?5\./ ) {
    shift @args;
  } elsif ($p =~ /^blead/ ) {
    my $srcdir = $c->config->{'perl-git'} or $c->_fail("blead needs perl-git");
    my $v = `$^X -ane'print \$F[2] if /PERL_API_VERSION/' $srcdir/patchlevel.h`;
    my $sv = `$^X -ane'print \$F[2] if /PERL_API_SUBVERSION/' $srcdir/patchlevel.h`;
    $p = "5.$v.$sv".substr($p,5); 
    $args[0] = 'blead'; # set $from
  } else {
    $c->output("perlall build missing perlversion argument\n");
    $c->execute('help') and return undef;
  }
  $p =~ s/^perl//;
  $p =~ s/^-//;
  if ($p =~ /[\*\?\[]/ or $p !~ /^5\.\d/) {
    $c->output("perlall build invalid perlversion argument $p\n");
    $c->execute('help') and return undef;
  }
  $c->stash->{log} = $c->stash->{logprefix} . $p;
  $c->_log("perlall",_opts($c->options),"build",$p,@args);
  $c->_fail("build not yet supported on Windows") if $^O eq 'MSWin32';
  my $srcdir;
  my $cwd = Cwd::getcwd();
  END { chdir $cwd if $cwd }

  my $root = $c->config->{PERLALL_BUILDROOT};
  my $prefix = $c->config->{PERLALL_PREFIX};
  unless ($root) {
    $c->_fail("Empty PERLALL_BUILDROOT in .perlall");
  }
  unless (-d $root) {
    $c->_system1( "mkdir",$root) 
      and $c->_fail("Cannot create PERLALL_BUILDROOT $root");
  }
  my $make = $Config{make};
  my $sed = $Config{sed};
  $sed = "sed" unless $sed;
  my $cp = $Config{cp};
  $cp = "cp" unless $cp;
  my $rm = $Config{rm};
  $rm = "rm" unless $rm;
  my $sudo = $c->config->{sudo};
  $sudo = "" unless $<; # already sudo

  my $from = shift @args ; # might be empty
  my $gitsuffix;
  my $ps = $p;
  my $dryrun = $c->options->{dryrun};
  $ps =~ s/\-.+$//;
  $ps =~ s/@.+$//;
  $ps =~ s/thr$// if $c->config->{usethrsuffix};
  $ps =~ s/d$//;
  # since when was make test parallel safe?
  my @j = ("-j".$c->options->{j}) if $c->options->{j} and !$c->_older( $ps, "5.10.0");

  unless ($from) {
    # XXX git only at first
    if ($ps =~ /^5\./ and -d $c->config->{'perl-git'}) {
      $from = $c->_older($ps,"5.11.0") ? "perl-$ps" : "v$ps";
    } else {
      $c->_fail ("could not determine from argument for $p. perl-git missing?");
    }
  }
  $c->_log("chdir $root") unless $c->options->{quiet};
  chdir $root unless $dryrun;

  $gitsuffix = $from unless $from =~ /^(perl-|v)5\./;
  if ($gitsuffix) {
    $srcdir = $c->config->{'perl-git'};
    if ($gitsuffix =~ /^[a-f0-9]{5,24}$/) {
      $gitsuffix = "@".substr($gitsuffix,0,6);
    } else {
      if ($gitsuffix =~ /^blead/ and !$dryrun and -d "$srcdir/.git") {
	chdir $srcdir;
	$gitsuffix = substr(`git rev-parse $gitsuffix`,0,8);
	chdir $root;
      }
      $gitsuffix =~ s/^smoke-me\///;
      $gitsuffix =~ s/\W//; # collapse non-word chars
      $gitsuffix = "@".substr($gitsuffix,0,12);
    }
    $p .= $gitsuffix unless $p =~ /@/;
  }
  my $builddir = "build-".$p;
  # XXX maybe it already exists and is not empty
  if ($from) { # looks like a file/url or more like a git branch/tag/commit
    # file
    if (-f $from or $from =~ /^https?:|ftp:|rsync:/) {
      warn "XXX build from file very very unstable.\n"
	.  "No idea how to know the resulting srcdir yet";
      if (!-f $from) {
	# try CPAN instead?
	$c->_system1( "wget","-O","perl-$ps.tgz",$from) 
	  and $c->_fail("downloading $from failed");
	$from = "perl-$ps.tgz";
      }
      my @tarx = (($^O eq 'solaris' ? 'gtar' : 'tar'),
	  ($from =~ m/bz2$/ ? 'xjf' : 'xzf' ));
      $c->_system1( @tarx, $from) and _fail("extracting the tarball $from failed");
      $srcdir = $root."/perl-$ps";
      if (! -d $builddir) {
	# OOPS LOOKS LIKE AN ERROR
	$c->_system("mkdir", $builddir)
	  and $c->_fail("Cannot create $builddir."
		    ." Check your PERLALL_BUILDROOT in ~/.perlall");
      }
      $c->_system1( "chdir", $builddir);
    }
    else { # git, much better
      $srcdir = $c->config->{'perl-git'};
      $c->_fail("perl-git $srcdir missing") if !-d $srcdir and !$dryrun;
      $gitsuffix = $from unless $from =~ /^(perl-|v)5\./;
      my @cmd = ("mkdir", $builddir);
      unshift @cmd, $sudo if $sudo and !-w $builddir;
      $c->_system1( @cmd) unless -d $builddir;
      $c->_fail( "invalid builddir $builddir") if !-d $builddir and !$dryrun;
      $c->_system($sudo, "chown", $<, $builddir) if $sudo eq $cmd[0];

      if (!$gitsuffix and !$c->options->{link}) { # cp anew
	$c->debug("copy full git tree anew for $from, no gitsuffix");
	@cmd = ($cp, "-r", "$srcdir/.git", "$builddir/");
	# unshift @cmd, $sudo if $sudo; # cannot trust !-w "$builddir/.git";
	$c->_system1( @cmd);
	$srcdir = "."; # clean copy

	$c->_system1( "chdir", $builddir);# and $c->_fail( "invalid builddir $builddir");
	$c->_system1( "git","checkout","-f",$from); # git returns strange values, ignore
	$c->_fail("git checkout -f $from") if !-f "Configure" and !$dryrun;
	if ($srcdir eq "." and !$gitsuffix) {
	  $c->_system1( "git","reset","--hard");
	}
      } else { # mksymlink for blead or branches
	$c->debug("working symlinked to perl-git tree \@$gitsuffix");
	$c->_system1( "chdir", $builddir);# and $c->_fail( "invalid builddir $builddir");
      }
    }
  }

  # Backport various Configure and hints patches from blead
  # via Devel::PatchPerl
  Devel::PatchPerl::patch_source($ps) unless $dryrun;

  $c->_system( $make, @j, "clean") if -f "Makefile" and -f 'miniperl';
  $c->_system( $rm, "config.h") if -f "config.h";
  $c->_system( $rm, "config.sh") if -f "config.sh";
  $c->_system( $rm, "Policy.sh") if -f "Policy.sh";
  $c->_system( $rm, "-rf", "UU") if -d "UU";
  $c->_system( $rm, "-rf", ".config") if -d ".config";

  # prepare configure options, dependent on options and $p
  my @conf = ("sh","$srcdir/Configure","-de","-Dusedevel",
	      "-Dinstallman1dir=none","-Dinstallman3dir=none",
	      "-Dinstallsiteman1dir=none","-Dinstallsiteman3dir=none");
  # we cannot force archname, because we don't know the resulting name yet
  # we fix that post-configure
  # XXX However we should honor -Darchname
  my $debug = $p =~ /\dd-?/;
  my $ithreads = $p !~ /\dd?-nt/;
  my $multi = $p !~ /\dd?-m/;
  my ($libperl, $olddll);
  if ($c->config->{usethrsuffix}) {
    $ithreads = $p =~ /\dd?thr/; # perl5.14.2dthr
  }
  push @conf, "-Dmksymlinks" if $srcdir ne "." and (!$gitsuffix or $c->options->{link});
  push @conf, "-DEBUGGING" if $debug;
  push @conf, "-Doptimize=-g3" if $debug and $Config{gccversion}; #-g is lame
  push @conf, "-Dusemultiplicity" if $p =~ /\dd?-m/;
  push @conf, ($ithreads ? "-D" :"-U") . "useithreads";
  push @conf, "-D'".$_."'" for @{$c->options->{D}};
  push @conf, "-A'".$_."'" for @{$c->options->{A}};
  push @conf, "-U'".$_."'" for @{$c->options->{U}};
  # special *perl<xxx>.dll if non-default
  if ($^O =~ /cygwin|MSWin32/ and -f 'config.sh'
      and ($gitsuffix or $debug or !$ithreads))
  {
    my $dll = `$^X -ne"if (/libperl='(.+)'/){print \$1}" config.sh` unless $dryrun;
    $dll = "fake.dll" if $dryrun;
    $libperl = $olddll = $dll;
    my $suff = "";
    $suff .= "d" if $debug;
    $suff .= "-nt" if $ithreads;
    $suff .= "-m" if $multi;
    $suff .= "@$gitsuffix" if $gitsuffix;
    $libperl =~ s/(\d)\.dll/$1$suff.dll/ if $suff;
    push @conf, "-Dlibperl=$libperl" if $libperl;
  }
  $c->debug("config_args: ".join(" ",@conf));
  for my $tryperl ("/usr/local/bin/perl", "/usr/bin/perl") {
    if (-e $tryperl) { # use tryperl as template and merge options
      my $tryargs = `$tryperl -V:config_args`;
      $c->debug("old args: $tryargs");
      for my $f (qw(cc ld ccflags ldflags libpth incpth pager
		    cf_email perladmin useshrplib))
      {
	next if grep /^$f[= ]/, @{$c->options->{D}}
	     or grep /^$f[= ]/, @{$c->options->{A}}
	     or grep /^$f[= ]/, @{$c->options->{U}};
	my ($d,$v) = $tryargs =~ /-([AUD])$f=(.+?) /;
	if ($f =~ /^use/ and !$v) {
	  my ($u) = $tryargs =~ /-([DU])$f /;
	  $c->debug("-$u$f") if $u;
	  push @conf, "-$u$f" if $u;
	} elsif ($v and $d) {
	  # There can be multiple -A$f=$v
	  if ($d eq 'A') {
	    my @v = ($tryargs =~ /-A$f=(.+?) /g);
	    for my $v (@v) {
	      $c->debug("-$d$f=$v") if $v;
	      push @conf, "-$d$f='$v'";
	    }
	  } else {
            # avoid the BSDPAN ports hack, we do not want to register our modules with ports
	    next if $^O =~ /bsd/ and $f eq "ccflags" and $v =~ /APPLLIB_EXP.*BSDPAN/;
	    $c->debug("-$d$f=$v");
	    push @conf, "-$d$f='$v'";
	  }
	}
      }
      $c->debug("merged config_args: ".join(" ",@conf));
      last;
    }
  }
  # XXX <= 5.10.1 debian: empty perllibs in config.sh and thus libs in Makefile
  # XXX darwin: if -m32 or -m64 use -flat_namespace to avoid 2level
  if ($^O eq 'darwin') {
    my $conf = join(" ",@conf);
    push @conf, "-Aldflags=-flat_namespace"
      if $conf =~ /ccflags=-m64/ or $conf =~ /ccflags=-m32/;
  }

  # with git branches prefer to cp to keep the debugging src,
  # no mksymlinks. --link only if you have not enough space.
  if ($gitsuffix and !$c->options->{link}) {
    $c->_system1( "cp -r $srcdir/* ." );
    $conf[1] = "Configure";
  }
  $c->_system1( @conf);
  $c->_fail("Configure failed") unless -f 'config.sh' or $dryrun;

  # fix libs on debug and git-stuff
  if ($gitsuffix or $debug or $^O eq 'darwin') {
    $c->debug("post-configure archname fixes");
    my $arch = `$^X -ne"if (/^archname='(.+?)'/){print \$1}" config.sh` unless $dryrun;
    #my $arch = `grep ^archname= config.sh|cut -c10-` unless $dryrun;
    #chomp $arch;
    $arch = "fake-arch" if $dryrun;
    $arch =~ s/'//g;
    my $new = $arch;
    $new .= "-debug" if $debug and $arch !~ /-debug/;
    $new .= $gitsuffix if $gitsuffix  and $arch !~ /$gitsuffix$/;
    for my $d (@{$c->options->{D}}) {
      if ($d =~ /^archname/) {
	# XXX parse and set
	$new = $d;
	$new =~ s/^archname=//;
      }
    }
    $c->_fail("Configure failed") unless $arch;
    # XXX This is very fragile!
    $c->_grep( "s,$arch,$new,; print", "config.h", "config.sh", "Policy.sh", "myconfig")
      if $arch and $arch ne $new;
  }
  if ($^O =~ /cygwin|MSWin32/ and ($gitsuffix or $debug or !$ithreads)) {
    $c->debug("post-configure perl.dll fixes");
    my $dll = `$^X -ne"if (/^libperl='(.+?)'/){print \$1}" config.sh` unless $dryrun;
    $dll = "fake.dll" if $dryrun;
    if ($libperl eq $dll) {
      $c->_log("configure did keep our libperl, good");
    } else {
      $c->_grep("s,$olddll,$libperl,", 
		"config.h", "Makefile", "GNUmakefile", "myconfig")
	if $libperl and $olddll;
    }
  }
  if ($^O eq 'darwin') { # darwin hints overwrote ld
    $c->debug("post-configure darwin ld fixes");
    my $ld = $dryrun ? "env MACOSX_DEPLOYMENT_TARGET=10.3 cc" 
      : `$^X -ne"if (/^ld='(.+?)'/){print \$1}" config.sh`;
    my $cc = $dryrun ? "cc" : `$^X -ne"if (/^cc='(.+?)'/){print \$1}" config.sh`;
    if ($ld ne $cc) {  # XXX and honor cmdline -Dld=
      $c->_grep( "s,^ld='$ld',ld='$cc',; print", "config.sh");
    }
  }
  $c->debug("post-configure startperl fixes");
  $c->_grep( "s,bin/perl$ps,bin/perl$p,; print", "config.h", "config.sh")
    if $ps and $ps ne $p;
  my $makefile = -f "GNUmakefile" ? "GNUmakefile" : "makefile";
  if (!$dryrun and `grep '<command-line>' $makefile`) { # <5.8.8?
    $c->debug("post-configure old-perl Makefile fixes");
    $c->_grep( "print unless /<command-line>/", $makefile, "x2p/$makefile");
  }

  $c->_system1( $make, @j); 
  if ($c->cmd eq 'smoke') {
    return $c->execute('_smoke', $p, $from, @j); # XXX not yet
  }
  my $testerr = $c->_system( $make, @j, "test") unless $c->options->{notest};
  $c->_system1( $make, @j, "install", "DESTDIR=$root/inst-$p")
    if !$testerr or $c->options->{force};

  # XXX on freebsd and windows there's no sudo. well in freebsd ports there is
  # do we need sudo? check writable
  if (-f "$root/inst-$p/usr/local/bin/perl$ps") {
    my @c = ($cp, "$root/inst-$p/usr/local/bin/perl$ps","$prefix/bin/perl$p");
    $sudo = "" if $sudo and -w "$prefix/bin/perl$p";
    unshift @c, $sudo if $sudo;
    $c->_system1( @c);

    @c = ($cp, "-r", "$root/inst-$p/usr/local/lib", "$prefix/");
    # $sudo = "" if $sudo and -w "$prefix/lib/perl5/$ps"; #wrong
    unshift @c, $sudo if $sudo;
    $c->_system1( @c);

    if (!$testerr and !$gitsuffix and $srcdir eq "." and -d '.git') {
      $c->_system1( "rm","-rf",".git");
    }
  }

  chdir $cwd;
  _set_alias($c, $p);

  print $c->output() if $c->options->{verbose};
  return "$prefix/bin/perl$p faked" if $dryrun;
  return -f "$prefix/bin/perl$p"
    ? "$prefix/bin/perl$p installed"
    : "$prefix/bin/perl$p failed to install";
}

=item install  [ perl<version><suffix> [ from ]]

Same as build

=item B<uninstall> perl<version><suffix>

Uninstalls the given version.

=cut

sub uninstall
  :Help('sudo rm /usr/local/bin/perl <arg> and its libs')
{
  "unimplemented";
}

=item B<smoke> [OPTIONS] perl<version><suffix> [ from ]

Same as C<build>, but reports the testresults to the smokers mailing list.
C<from> may be a wildcard for multiple smoke branches, as C<smoke-me/*>.

Description and OPTIONS see L</build>.

=cut

sub _smoke
{
  return "unimplemented";
}

=item B<init> [perl-<version><suffix> [<modules>...]]

=item perlall="5.*" B<init> [<modules>...]

Installs and updates basic CPAN modules.

Default: C<init-modules> in F<~/.perlall>
   (YAML DBI DBD::SQLite CPAN::SQLite Devel::Platform::Info 
   Params::Util Bundle::CPANReporter2 
   B::Flags Opcodes  Math::Round Params::Classify $(cat ~/Perl/B-C/t/top100)
   Bundle::CygwinVendor YAML::XS DBIx::Class SQL::Abstract Module::Find Mouse 
   MouseX::Types Task::Kensho)

Default: C<cpan>=C<cpan> or C<cpanm> in F<.perlall>
Todo: cpan=-MCPAN

=cut

sub init
  :Help('Installs and updates basic CPAN modules')
{
  my $c = shift;
  my @argv = @{$c->argv};
  my $mods = @argv ? join(" ",@argv) : $c->config->{'init-modules'};
  return "missing config init-modules" unless $mods;
  my $cpan = $c->config->{'cpan'};
  $cpan = 'cpan' unless $cpan;
  $c->options->{verbose} = 1;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    # XXX if App::cpan exists and works ok, -S cpan
    #     otherwise need -MCPAN -e'install qw(mods)'
    # use_sqlite bootstrap: YAML DBI DBD::SQLite CPAN::SQLite
    qx($p -MCPAN::SQLite -e0); if ($!)  {# okay
      $c->_system( $p, "-MCPAN", '-e"install qw(DBI DBD::SQLite)"');
    }
    $c->_system( $p, "-S", $cpan, split / /,$mods);
  }
  $c->_set_alias();
}

=item B<list> [version*]

List all installed perlall versions

=cut

sub list
  :Help('List all installed perlall versions')
{
  my $c = shift;
  return join "\n", @{$c->stash->{perlall}};
}

=item B<do> command

Execute commands with all perls from $ENV{perlall}.

For example, run a Hello program:

    perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5*; do
    echo $perl $*
    $perl $*
  done

Restricts perls via ENV:

  perlall="5.14.*d*" perlall do -E'say "Hello from $]"'

is expanded to something like:

  for perl in /usr/local/bin/perl5.14.*d*; do
    echo $perl $*
    $perl $*
  done

The output depends on your perl installations, and looks like this:

    perl5.12.2-nt -E'say "Hello from $]"'
    Hello from perl-5.012002
    
    perl5.12.3-m -E'say "Hello from $]"'
    Hello from perl-5.012003
    
    perl5.14.2 -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.14.2d-nt -E'say "Hello from $]"'
    Hello from perl-5.014002

    perl5.8.9-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

    perl5.6.2-nt -E'say "Hello from $]"'
    Unrecognized switch: -E  (-h will show valid options).

Notice that the commands are not executed in parallel.

=cut

sub do
  :Help('Execute commands with all perls') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    $c->_system( $p, @{$c->argv});
  }
  $c->_set_alias();
}

=item B<cpan> modules

like C<perlall do>, but calls perl5.* -S cpan args... for all perls

=cut

sub cpan
  :Help('Call cpan with args for all perls') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    $c->_system0($p, "-S", "cpan", @{$c->argv});
  }
  $c->_set_alias();
}

=item B<cpanm> modules

like C<perlall cpan>, but uses cpanm.

=cut

sub cpanm
  :Help('Call cpanm with args for all perls') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  return "missing args" unless $argv;
  for my $p (@{$c->stash->{perlall}}) {
    $c->stash->{log} = $c->stash->{logprefix} . _short($p);
    $c->_system0($p, "-S", "cpanm", @{$c->argv});
  }
  $c->_set_alias();
}

=item B<make> args

like C<perlall do>, but prepends C<make -s clean; $perl Makefile.PL; make> 
before executing the arguments.

Also is Build.PL aware but prefers Makefile.PL.

=cut

sub _make {
  my $c = shift;
  my $p = shift;
  my $make = $Config{make};
  # checks MB
  $c->_system( $make, "-s", "clean") if -f "Makefile";
  $c->stash->{log} = $c->stash->{logprefix} . _short($p);
  if (-f "Makefile.PL") {
    $c->_system( $p, "Makefile.PL");
    $c->_system0( $make);
  } elsif (-f "Build.PL") {
    # this is broken and needs a realclean
    $c->_system( "./Build", "realclean") if -f "Build" and $^O ne 'MSWin32';
    $c->_system( "rm", "-rf", "blib", "_Build", "Build" ) if $^O ne 'MSWin32';
    $c->_system( $p, "Build.PL");
    $c->_system0( $p, "Build");
  }
}

sub make
  :Help('Do perl Makefile.PL; make for all perls') 
{
  my $c = shift;
  my $argv = join " ",@{$c->argv};
  my $make = $Config{make};
  for my $p (@{$c->stash->{perlall}}) {
    $c->_make( $p);
    if ($argv) { # preserves quotes as in -e'my $a;'
      $c->_system0( $p, @{$c->argv});
    }
  }
  $c->_set_alias();
}

=item B<maketest>

like C<perlall make>, but runs C<make test TEST_VERBOSE=1> after C<make>.
This is the most used feature.

On C<--quiet> or C<-q> does not do TEST_VERBOSE=1

=cut

sub maketest
  :Help('Do make; make test for all perls') 
{
  my $c = shift;
  my $make = $Config{make};
  warn "additional arguments @{$c->argv} ignored\n" if @{$c->argv};
  for my $p (@{$c->stash->{perlall}}) {
    $c->_make($p);
    my @opts = ("test", $c->options->{quiet} ? () : "TEST_VERBOSE=1");
    unshift @opts,"-j".$c->options->{j} 
      if $c->options->{j} and !$c->_older( $p,"5.10.0");
    if (!-f "Makefile" and -f "Build") {
      $c->_system0( $p, "Build", @opts);
    } else {
      $c->_system0( $make, @opts);
    }
  }
  $c->_set_alias();
}

=item B<makeinstall>

like C<perlall maketest>, but runs C<sudo make install> after C<make test>.

=cut

sub makeinstall
  :Help('Do make test && sudo make install for all perls') 
{
  my $c = shift;
  my $make = $Config{make};
  # XXX check MyCPAN.pm for sudo
  warn "additional arguments @{$c->argv} ignored\n" if @{$c->argv};
  my $sudo = $c->config->{sudo};
  for my $p (@{$c->stash->{perlall}}) {
    $c->_make($p);
    $c->_system0( "$make test && $sudo $make install"); # csh?
  }
  $c->_set_alias();
}


=item B<testvm> [OPTIONS] [user@]hostname...

Does C<perlall maketest> in parallel on remote machines.
C<testvm> is only usable within a perl core builddir/srcdir
or in a module rootdir.
It shells out to ssh account(s), copies the files in MANIFEST
to the machine, runs C<perlall maketest> there and copies the
logfiles back.

Options:

    --all|a    - all hosts defined in config C<testvm>
    --up       - only upload local MANIFEST files
    --prefix|p=Perl - remote basedir
    --cmd|c=<remotecmd> any valid perlall command, like
               build, init, makeinstall, smoke. Default: maketest
    --option|o="" remaining remote perlall cmd options and args
    --max|j 4  - how many machines in parallel. (NOT YET) 

Config settings:

    testvm="[user@]hostnames..."
    testvm_prefix=Perl - relative remote basepath of your modules
          i.e. local basename = B-Generate => remote: vmhost:Perl/B-Generate
    testvm_max=4       - balancing, default for -j
    testvm_ctl=virsh   - type of vm ctl: virsh, xen-shell, vmrun, VBoXManage

VM Balancing:

    If the remote hosts are VM's on this machine, you can control how many
    VM's should run in parallel, and how they are started and stopped.

    If C<testvm_ctl> is not set, no balancing - start+stop - will be done,
    such as on physical hosts or enough VM power.
    See F<.perlall>

=cut

sub testvm
  :Help('Test on remote accounts via ssh/rsync (vm or host)')
{
  my $c = shift;
  # testvm has a different option set and allows options after the command
  $c->addopts( "all|a", "up", "prefix|p=s", "cmd|c=s", "option|o=s"); #, "max|j=n" );

  my ($prefix, $base);
  my @testvm = split //,$c->config->{testvm};
  my @machines = $c->options->{all} ? @testvm : @{$c->argv};
  return "missing args" unless @machines;

  # XXX Expand glob-style machines
  # Idea: - check /etc/hosts so testvm can be empty?
  #       But then we have to check the network for possible machines,
  #       or we want to do all hosts in /etc/hosts?
  #       - check hosts in .ssh/known_hosts
  # XXX check if in core or in a module
  _print1("perlall testvm "._opts($c->options),@machines)
    if $c->options->{verbose};
  $c->stash->{log} = $c->stash->{logprefix};
  my $cmd = $c->options->{cmd} || "maketest";
  my $opt = $c->options->{option} || '';
  my $man = 'MANIFEST';
  $c->_fail("$man not found") unless -f $man;
  my $f = 'MANIFEST.files';
  if ( -M $man > -M $f ) {
    print "Creating $f\n" unless $c->options->{quiet};
    open M,'<',$man; open F,'>',$f;
    while (<M>) {
      print F $_ unless /^#/;
    }
    close M; close F;
  }
  $prefix = $c->options->{prefix} || "Perl";
  $base = basename(Cwd::getcwd);
  for my $m (@machines) {
    $c->_system("rsync","-avzL","--delete",
		'--files-from=MANIFEST.files',
		'.', "$m:$prefix/$base/");
    $c->_system1("ssh",$m,"cd $prefix/$base && perlall $cmd $opt")
      unless $c->options->{up};
  }
  "testvm done on @machines"
}

=item B<initvm> user@[hostname] [MODULES]

copies pubkey to host:.ssh/authorized_keys if not exists

copies perlall to host:bin/

ssh hostname perlall init MODULES

=cut

sub initvm
  :Help('Init remote perlall via ssh/rsync (vm or host)')
{
  my $c = shift;

  my $m = shift @{$c->argv};
  return "missing host" unless $m;

  _print0("perlall initvm $m ",@{$c->argv})
    if $c->options->{verbose};
  $c->stash->{log} = $c->stash->{logprefix};
  unless (`ssh $m ls .ssh/authorized_keys` =~ /authorized_keys$/m) {
    for my $t (/ecdsa dsa rsa /) {
      if (-f "$ENV{HOME}/.ssh/id_$t.pub") {
	_print1 "rsync -avzL ~/.ssh/id_$t.pub >>$m:.ssh/authorized_keys"
	  unless $c->options->{quiet};
	qx(rsync -avzL $ENV{HOME}/.ssh/id_$t.pub $m:.ssh/copied.pub);
	qx(ssh $m cat .ssh/copied.pub >> .ssh/authorized_keys);
	last
      }
    }
  }
  $c->_system1("rsync","-avzL",$0,"$m:bin/perlall");
  # check .perlall, and cpan deps
  unless (`ssh $m ls .perlall` =~ /.perlall$/m) {
    $c->_system1("rsync","-avzL","$ENV{HOME}/.perlall","$m:.perlall");
  }
  $c->_system1("ssh $m 'perl -MCPAN -e\"install qw/App::Rad IO::Tee Devel::Platform::Info Devel::PatchPerl/\"'");
  # XXX we are not sure if bin is in the PATH
  #$c->_system1("ssh",$m,"'bin/perlall -v init ".join(" ",@{$c->argv})."'");
  "initvm done on ".$m
}

=item B<selfupgrade>

This command upgrades perlall to its latest version.

=cut

sub selfupgrade
  :Help('Upgrade perlall to its latest version')
{
  my $c = shift;
  "unimplemented" # see perlbrew
}

=item B<help>

prints this help. With -v even more.

=cut

sub help
  :Help('List of commands. With -v more')
{
  my $c = shift;
  $c->addopts( 'verbose|v' );
  require Pod::Usage;
  return Pod::Usage::pod2usage
    ( { -message => App::Rad::Help::usage() . "\n\n"
	. App::Rad::Help::helpstr($c),
	-verbose => $c->options->{verbose} ? 3 : 0,
      } );
}

=item B<version>

=cut

sub version
  :Help('Print version')
{
  # hardlink variants (perlall-make, ...)
  print basename($0)." $main::VERSION\n";
  exit;
}

=back

=head2 OPTIONS

=over

=item B<--skip> C<versions>

versions might be a glob-style regex.
E.g. --skip '5.1[024]d*'

=item B<--newer> C<versions>

Only with newer versions than. versions might be a glob, 
including a special arch suffix.
E.g. perlall do --newer "5.10.?d-nt" 

=item B<--older> C<versions>

versions might be a regex. As in --newer.

=item B<-q| --quiet>

Make perlall command quieter.

=item B<-v| --verbose>

Make perlall command say more.

For C<build>, this prints the whole build and test process to STDOUT.

=back

=head1 CONFIGURATION

B<~/.perlall> or F</etc/perlall>

This is shell-script syntax with ENV vars and aliases.
C<alias p=$perlall> is also written by C<perlall>.

=over 4

=item alias p=perl5.15.4d-nt

Save current perl.

This is stored after each perlall execution.
Dependend on p there are several other handy p aliases,
which are active if you source them from your F<~/.profile>
See F<.perlall>

=item alias perl-git="cd /usr/src/perl/blead/perl-git"

git repo to avoid downloading perl-*.tar.gz from CPAN.

C<perl-git> stores the perl git root, and is also a handy alias to cd into it.

=item PERLALL_PREFIX

Where perls are installed into. Default: /usr/local

=item PERLALL_BINDIR

Where perl5.* binaries are expected. Currently built into
PERLALL_PREFIX/bin only.

Default: PREFIX/bin but can also be ~/perl5/perlbrew/bin

=item PERLALL_BUILDROOT

Where perls are built. 
Default: /usr/src/perl

=item cpan

For init only.

C<cpan> or C<cpanm> (C<-MCPAN> not yet)

=item init-modules

List of CPAN module names for C<init>

=item sudo

Default: "sudo". Or "" on freebsd|cygwin|msys|MSWin32

=item testvm

See L</testvm>.

=back

=head1 SEE ALSO

The bash scripts, which I used for some years:
L<http://github.com/rurban/dot-bin/blob/master/perlall-makeinstall>

L<App::perlbrew> which looked like my bash scripts and B<perlall>,
but pollutes PERL5LIB and thus your whole environment, similar to
the horrible Oracle perl.

=cut
